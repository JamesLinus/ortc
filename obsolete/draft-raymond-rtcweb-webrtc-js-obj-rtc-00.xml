<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<rfc ipr="trust200902" docName="draft-raymond-rtcweb-webrtc-js-obj-rtc-00" category="std">

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

  <front>
    <title>WebRTC JavaScript Object RTC</title>

    <author initials="R." surname="Raymond" fullname="Robin Raymond">
      <organization>Hookflash</organization>
      <address>
        <postal>
          <street>436, 3553 31 St. NW</street>
          <city>Calgary</city>
          <region>Alberta</region>
          <code>T2L 2K7</code>
          
        </postal>
        
        
        <email>robin@hookflash.com</email>
        
      </address>
    </author>
    <author initials="C." surname="Dorn" fullname="Christoph Dorn">
      <organization>Independent</organization>
      <address>
        <postal>
          <street>1999 Highway 97 South</street>
          <city>West Kelowna</city>
          <region>BC</region>
          <code>V1Z 1B2</code>
          <country>Canada</country>
        </postal>
        
        
        <email>christoph@christophdorn.com</email>
        
      </address>
    </author>
    <author initials="E." surname="Lagerway" fullname="Erik Lagerway">
      <organization>Hookflash</organization>
      <address>
        <postal>
          <street>436, 3553 31 St. NW</street>
          <city>Calgary</city>
          <region>Alberta</region>
          <code>T2L 2K7</code>
          <country>Canada</country>
        </postal>
        
        
        <email>erik@hookflash.com</email>
        
      </address>
    </author>
    <author initials="I." surname="Baz Castillo" fullname="Inaki Baz Castillo">
      <organization>Versatica</organization>
      <address>
        <postal>
          <street>Barakaldo</street>
          <city>Basque Country</city>
          
          
          <country>Spain</country>
        </postal>
        
        
        <email>ibc@aliax.net</email>
        
      </address>
    </author>
    <author initials="R." surname="Shpount" fullname="Roman Shpount">
      <organization>TurboBridge</organization>
      <address>
        <postal>
          <street>4905 Del Ray Ave Suite 300</street>
          <city>Bethesda</city>
          <region>MD</region>
          <code>20814</code>
          <country>USA</country>
        </postal>
        
        
        <email>rshpount@turbobridge.com</email>
        
      </address>
    </author>

    <date year="2013" month="August" day="12"/>

    <area>General</area>
    <workgroup>Network Working Group</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This draft outlines an alternative approach to the current JSEP <xref target="I-D.ietf-rtcweb-jsep"/> / WebRTC 1.0 draft <xref target="WebRTC10"/> and removes the dependency requirements on the SDP <xref target="RFC4566"/> and Offer / Answer <xref target="RFC3264"/> state machine or reliance upon an all-encompassing master media description format that describes the entire RTP transport and media states. This draft describes how the WebRTC Use-cases and Requirements <xref target="I-D.ietf-rtcweb-use-cases-and-requirements"/> and Media Transport and Use of RTP <xref target="I-D.ietf-rtcweb-rtp-usage"/> are satisfied by such an alternative approach (where the use cases are applicable). The rationale for needing an alternative approach is described in the WebRTC JS Object API Rationale draft <xref target="I-D.raymond-rtcweb-webrtc-js-obj-api-rationale"/>.</t>

<t>This draft outlines how WebRTC signaling negotiation information required to perform RTC on-the-wire can be organized into object-like constructs to minimize cross-dependencies between negotiated information, round-trip signaling, and co-dependency in negotiated state transitions. This results in greater flexibility for signaling protocols other than those based on SDP/SIP <xref target="RFC3261"/> (but not to exclude SDP/SIP). The flexibility to implement other signaling options is achieved by not imposing an all-encompassing session description format and the offer / answer state machine, such as described in JSEP <xref target="I-D.ietf-rtcweb-jsep"/>. Finally, this draft outlines how a reference shim can be implemented on top of this proposal for those who would prefer a JSEP / SDP model for their signaling.</t>



    </abstract>


  </front>

  <middle>


<section anchor="problems" title="Introduction">

<t>This draft describes how an object-like construct model can be used to control the setup, manage, negotiate and control Real-Time Communications (RTC) from the Browser and how these concepts are transform into on-the-wire constructs, as an alternative to JSEP’s approach. The provided example-only API is presented merely as input guidelines for the W3C to ensure their API constructs allow for the correct interpretation to on-the-wire RTC control and signaling constructs needed as defined in the various use case drafts related to RTCWEB. The draft outlines an alternative JavaScript RTC control model that does not require a complex all-encompassing session description format, like SDP, or related offer / answer state machine to describe the entire transport and media states. This allows for greater flexibility with other non-SDP offer / answer based signaling protocols. The actual final API is entirely within the scope of the W3C (as it should be).</t>

<section anchor="general-design-of-webrtc-js-object-model" title="General Design of WebRTC JS Object Model">

<t>The design of this object model is to split the information required to setup a RTC session into logical object components, information and relationships where they are needed rather than on requiring a single all-encompassing RTC session description format and its related offer / answer state machine. Further, the coordination of the information that must be exchanged in signaling is left to the decision of the JavaScript developer to allow for a variety of signaling approaches, rather than imposing a single model with offer / answer.</t>

<t>By splitting the RTC concepts into logical objects components, the choice of approaches for the signaling path becomes even more flexible and the information needed for each component becomes minimized and much easier to standardize. The local object components can be replaced in the future should the information required for each component change, or if a new type of object is needed for different types of media or RTP engine features.</t>

<t>This WebRTC JavaScript object model approach still exposes all the key information required for various signaling models, but limits the information needed to only the information required to actually control the media engine and nothing more. For the average JavaScript developer, the objects model is simplistic but still allows those developers who require greater control and flexible access to the constructs they require from an RTC engine inside the browser without needing to perform extensive parsing, mangling and regeneration of a master know-everything session format (such as SDP).</t>

<t>The main design goals are to:</t>

<t><list style='numbers'>
  <t>allow multiple alternative on-the-wire signaling alternatives without imposing a know-everything media description format and related offer / answer state machine.</t>
  <t>mandate only the use of the RTC on-the-wire protocols needed to satisfy the use cases and requirements, as described in <xref target="I-D.ietf-rtcweb-use-cases-and-requirements"/> and related documents.</t>
  <t>allow granular information to be exchanged based upon logical objects in a method and timing decided best by the implementor.</t>
  <t>allow for control of the RTC engine with maximum flexibility, while still adhering to the unique security requirements of browsers.</t>
  <t>minimize the requirements needed for basic and simple JavaScript use cases.</t>
  <t>resolve the PlanA <xref target="I-D.roach-rtcweb-plan-a"/>, PlanB <xref target="I-D.uberti-rtcweb-plan"/> and NoPlan <xref target="I-D.ivov-rtcweb-noplan"/> conflicts arising from handling multiple media sources.</t>
  <t>borrow liberally from the concepts already proposed in other places where possible to merge the various concepts.</t>
  <t>resolve or limit as many of the concerns presented in the accompanying rationale document <xref target="I-D.raymond-rtcweb-webrtc-js-obj-api-rationale"/> as possible.</t>
</list></t>

</section>
<section anchor="other-approaches-considered" title="Other Approaches Considered">

<t>By not imposing a master transport and media description format, a JavaScript developer will not be exposed to a complex unfamiliar session description format with little high level control over what’s happening at protocol layers. The current SDP JSEP approach requires developers to perform extensive parsing, interpret or transform this master session description when more control is required. Decoupling a single describe-everything format and the state machine into logical well-defined components with no specific requirements on how the information must be exchanged allows for greater flexibility in signaling.</t>

<t>SDP is a complex format that describes many more things than are actually required to control an RTP engine. By not imposing a particular format, the net result should be less brittle implementations that are not dependent upon an ever evolving, adaptable and expanding master format.</t>

<t>Contrary to the assertions stated in JSEP <xref target="I-D.ietf-rtcweb-jsep"/> “1.2 Other Approaches Considered”, the WebRTC JavaScript object model proposed does not result in overly complex JavaScript code to perform simple and basic WebRTC implementations. The simple scenarios for RTC control from JavaScript are no more complex than the simple JSEP examples and do not require dependency on additional libraries to create a reasonable reference implementation. Whereas the complexity required to implement other more advanced scenarios that do not follow the specific offer / answer state machine model is greatly reduced relative to JSEP’s requirements. The manual manipulation and transformation of a complex session description format generated by the browser is all but eliminated. Only those who must implement a particular type of session format will be required to parse and generate that format without imposing that format upon others, and amongst those who need a particular format, their output will be tailored to their exacting needs.</t>

<t>The WebRTC JS Object Model does not implement or add any features other than those already existing in WebRTC 1.0, but because of it’s granular object based approach, it allows for a variety of alternative signaling scenarios that are difficult to achieve with the current WebRTC API <xref target="WebRTC10"/>. In fact, the requirements for a browser are eased by virtue of not having to handle an all-encompassing media description format with an offer / state machine. Both a JSEP or object based model would need to perform all the same logic routines internally, including all the RTP data muxing rules, but the WebRTC object model removes many of the unneeded restrictions and burdens placed on a JavaScript developer and the browser vendor on how a signaling protocol must work.</t>

</section>
</section>
<section anchor="terminology" title="Terminology">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 <xref target="RFC2119"/>.</t>

</section>
<section anchor="object-data-and-control-model" title="Object, Data and Control Model">

<section anchor="objsocket" title="RTC Socket">

<t>This object represents a local media IP port opened to send and receive media or data. Each port is capable of carrying RTP, RTCP, or DTLS/SCTP streams but the mapping of what each socket must be under the control of the Javascript layer.</t>

<t>The developer must be able to provide each of these sockets a list of stun and turn servers. This allows the socket to discover other network-reflective port mappings and open up relay network sockets to allow the socket to be “remoted” when direct media connections to the socket are not possible.</t>

<t>The socket must support DTLS <xref target="RFC6347"/> / SCTP <xref target="RFC4960"/>), the developer’s JavaScript must be able to must be able to obtain the fingerprint utilized in the private / public certificate pair generated by the browser (for further discussion on this issue see the Security Section (<xref target="fingerprintresponsibility"/>)).
354</t>

</section>
<section anchor="objconnection" title="RTC Connection">

<t>A connection is an object that represents the logical connection between two Internet peers. Each peer constructs a connection object that gathers candidates (i.e. possible methods to connect over the Internet) from an RTC socket and allows an external signaling mechanism to exchange these candidates to each other. The peers test the candidates for connectivity and establish a connection once a candidate pairing discovers connectivity (see <xref target="I-D.rescorla-mmusic-ice-trickle"/>).</t>

<t>Once a connection is established on all sockets, an event must be fired to the developer’s JavaScript / application to indicate connectivity. The connection remains established until disconnected by programmatic intent or by timeout failure, upon which time a disconnect event must be fired to indicate the disconnection state with the appropriate listed reason. Should the connection fail to connect, a disconnection event must fire with the appropriate listed reason.</t>

<t>Once a connection is established between peers, a connection can be used to transmit media or data utilizing the associated media or data socket. Appropriate capabilities (<xref target="objcapabilities"/> / stream mappings) for each connection must be exchanged before media streams may flow between peers.</t>

<section anchor="relationship-to-socket" title="Relationship to Socket">

<t>Each connection {#objconnection} object must be related to a single socket ({#objsocket}), and multiple connections can share the same socket objects. This allows a single socket to be connected to multiple peers with a unique connection to each peer. A socket represents a single logical connection binding on a network interface, thus a unique ICE (<xref target="objice"/>) negotiation occurs for each connection since ICE negotiation represents a local to remote socket connection negotiation.</t>

</section>
<section anchor="objconnectiondescription" title="Connection Description">

<t>While a connection might have a variety of other properties, every connection object has a description structure that must have the following properties:</t>

<t><list style='symbols'>
  <t>connection-id - an identifier to distinguish between connection objects in stream/track mappings.</t>
  <t>iceUsernameFrag - a cryptographic random identifier for the connection auto-generated by the browser for use as the ICE userFrag.</t>
  <t>icePassword - a cryptographic random string serving as the ICE password.</t>
  <t>fingerprint - the hash fingerprint of any public keys certificate used in the sockets (see <xref target="fingerprintresponsibility"/>).</t>
</list></t>

<t>The ICE username frag, password and fingerprint must remain identical for every connection using the same RTC Socket object to allow for forking scenarios. This allows the developer to correlate forked connections as appropriate by a JavaScript developer.</t>

<t>The information contained in a connection’s description must be exchanged with a remote peer’s connection object before any candidate connectivity checks may be performed by the browser. The exact method and timing of the exchange must be left to the discretion of the JavaScript developer.</t>

<section anchor="connection-description-expressed-as-a-structure" title="Connection Description Expressed as a Structure">

<t>This is an example-only connection description expressed as a JavaScript structure. This example is not a signaling on-the-wire format mandate.</t>

<figure><artwork><![CDATA[
var myConnectionDescription = {
    connection-id: "<value>",
    iceUsernameFrag: "<random-id>",
    icePassword: "<random>",
    fingerprint: "<hash>"
};
]]></artwork></figure>

</section>
<section anchor="connection-description-negotiation" title="Connection Description Negotiation">

<t>The local peer has a connection description. The remote peer has a connection description. Each peer must exchange the information in the connection description with the other through signaling. The the iceUsernameFrag and the icePassword are used in the for ICE signaling process (see <xref target="RFC5245"/>).</t>

<t>Each connection has a fingerprint for each socket DTLS <xref target="RFC6347"/> / SCTP <xref target="RFC4960"/>. The fingerprint must be signaled in order to for each connection to ensure it’s connected to the correct remote peer. The connection object is responsible for ensuring any remotely connected peer’s fingerprint during DTLS exchange matches the fingerprint provided in the connection description of the remote peer. If the fingerprint does not match, the connection must be closed.</t>

<t>Example pseudo-code of how connection negotiated could be accomplished:</t>

<figure><artwork><![CDATA[
// alice makes offer
var alice_connection = new ORTC.Connection();
var aliceDesc = alice_connection.getDescription();

mysignal("to:bob", JSON.stringify(aliceDesc));

var bob_connection = new ORTC.Connection();
bob_connection.setDescription(JSON.parse(aliceDesc), "remote");
]]></artwork></figure>

</section>
</section>
<section anchor="objice" title="ICE">

<t>ICE <xref target="RFC5245"/> is a standard used for discovering peer connectivity. A browser must support both ICE, and the ICE modification extension trickle ICE <xref target="I-D.rescorla-mmusic-ice-trickle"/> connectivity discovery mechanisms. The browser may support additional peer connectivity methods other than ICE.</t>

<t>When the browser detects a candidate is available, the candidate must be sent as an event to the developer’s JavaScript. If all possible candidates have been discovered, the browser must send an end of candidates event to the developer’s JavaScript.</t>

<section anchor="ice-candidate-trickling" title="ICE Candidate Trickling">

<t>The browser must support trickle ICE <xref target="I-D.rescorla-mmusic-ice-trickle"/> discovery mechanism. This mechanism allows the browser to provide candidate information as they are discovered, thus allowing the developer’s JavaScript to exchange this information to a remote peer via signaling. As candidates are exchanged, the browser must perform connectivity checks as defined by trickle-ICE even while other candidates are still being discovered and exchanged via signaling (to allow for faster connection times).</t>

<t>Before any connectivity checks may be performed by a browser, a connection’s description information (<xref target="objconnectiondescription"/>) must be received from a remote peer’s connection.</t>

</section>
<section anchor="objcandidatedescription" title="ICE Candidate Description">

<t>Each ICE candidate has description information containing the following:</t>

<t><list style='symbols'>
  <t>connection id - the connection identifier where the candidate was discovered, matching the identifier specified in the RTC Connection (<xref target="objconnection"/>)</t>
  <t>foundation (as as defined in RFC5245 <xref target="RFC5245"/>)</t>
  <t>component id (as as defined in RFC5245)</t>
  <t>transport (as as defined in RFC5245)</t>
  <t>priority (as as defined in RFC5245)</t>
  <t>connection address (as as defined in RFC5245)</t>
  <t>connection port (as as defined in RFC5245)</t>
  <t>type (defined as “host”, srflx”, “prflx”, or “relay” whose meaning is derived from RFC5245)</t>
  <t>related address (as as defined in RFC5245)</t>
  <t>related port (as as defined in RFC5245)</t>
</list></t>

<t>The developer’s JavaScript should be able to transport the candidate description information ‘as is’ even if the description information is not understood so long as the developer’s signaling protocol allows for alternative candidate types.</t>

<t>The candidate descriptions may be relayed to the remote peer independent of other description information or bundled together with other descriptions as determined by the needs of the JavaScript developer. The browser must not impose restrictions on external signaling protocols related to the exchange of candidates, or require the bundling of other types of descriptions, such as capabilities descriptions (<xref target="objcapabilities"/>) or stream descriptions (<xref target="objstreamdescriptions"/>).</t>

<section anchor="candidate-description-expressed-as-a-structure" title="Candidate Description Expressed as a Structure">

<t>This is an example-only candidate description expressed as a JavaScript structure. This example is not a signaling on-the-wire format mandate.</t>

<figure><artwork><![CDATA[
var myCandidateDescription = {
    connection-id: "<value>",
    foundation: 1,
    component: 1,
    transport: "udp",
    priority: 1694498815,
    connectionAddress: "192.0.2.33",
    connectionPort: 10000,
    type: "host"
    // relatedAddress: "1.2.3.4",
    // relatedPort: 34232
};
]]></artwork></figure>

</section>
</section>
</section>
<section anchor="objcapabilities" title="Capabilities">

<t>Capabilities consist of a list of media codecs and RTC options allowed to be used as part of the transmission of media. Capabilities can consist of additional rules or limitations, for example; video size or bandwidth limitations. A developer’s JavaScript must be able to obtain the types of capabilities supported by the browser (<xref target="objfeaturediscovery"/>), and the default set of codecs and algorithms available.</t>

<section anchor="capabilities-description-expressed-as-a-structure" title="Capabilities Description Expressed as a Structure">

<t>This is an example-only capabilities description expressed as a JavaScript structure. This example is not a signaling on-the-wire format mandate. Individual codecs may have varying properties according to the definition of each codec type.</t>

<figure><artwork><![CDATA[
var myCapabilities = {
    codecs: [
        {
            payloadId: 96,
            kind: "audio",
            name: "<name>",
            hzRate: 32000,
            channels: 1
            // ...
        },
        {
            payloadId: 96,
            kind: "video",
            name: "<name>",
            hzRate: 96000
            // ...
        }
    ],
    required: {
    },
    optional: {
        video: {
            maxWdith: 1280,
            maxHeight: 720
        }
    }
};
]]></artwork></figure>

</section>
<section anchor="capability-negotiation" title="Capability Negotiation">

<t>The media capabilities must be exchanged via some external signaling method by the developer’s JavaScript. The local capabilities must be (at minimal) a subset of the available capabilities of the local and remote peer. Should the browser be unable to fulfill the provided capabilities for any reason (for example, none of the codecs were compatible), an error most be propagated to the developer’s JavaScript, which should handle this condition rather than silently fail. The RTCWEB Working Group must define a mandatory common set of codecs to help alleviate the possibility of codec and algorithm failure conditions.</t>

<t>The browser must not dictate the timing or format of how capabilities are exchanged, nor the rules of how each peer must provide the information, nor how the information is signaled.</t>

<t>The browser should only support codecs that are well documented standards. The browser must namespace non-standard codecs using a method that will not cause confusion with codecs that might become standardized in the future. The properties for each standardized codec must be defined clearly. By defining each codecs’ properties, alternative signaling protocols may translate the standardized codecs into their respective signaling protocols. If a browser does not have specific knowledge of a codec supplied by a developer’s JavaScript, it must ignore the non-understood codecs. A JavaScript developer may encode and signal non-standard codecs so long as none of the browser provided properties are lost during signaling exchange.</t>

<t>Other non-codec capabilities and properties may be set for a connection. For example; a developer may wish to set the maximum video dimensions for a connection. The browser should only implement standardized capabilities and namespace non-standard capabilities to ensure that no conflict arises should capabilities become standardized.</t>

<t>A developer’s JavaScript may choose what capabilities to signal to a remote peer, or not. The developer must only set capabilities that are either understood, or were generated by the browser and signaled ‘as is’ to the remote party. A developer should attempt to signal all capabilities generated by the browser to the remote party, but may choose to filter only the understood capabilities.</t>

<t>The browser should only implement standardized capabilities and must namespace non-standardized capabilities appropriately to avoid conflict with capabilities that might be standardized in the future.</t>

<t>Example pseudo-code of how capabilities could be negotiated:</t>

<figure><artwork><![CDATA[
// alice signals capabilities to bob
var aliceCapabilities = JSON.stringify(
  alice_session.getCapabilities("receive"));
mysignal("to:bob", aliceCapabilities);

// bob changes sending capabilities
bob_connection.setCapabilities(
  JSON.parse(aliceCapabilities), "send");

// bob signals capabilities to alice
var bobCapabilities = JSON.stringify(
  bob_session.getCapabilities("receive"));
mysignal("to:alice", bobCapabilities);

// alice changes sending capabilities
alice_session.setCapabilities(JSON.parse(bobCapabilities), "send");
]]></artwork></figure>

</section>
</section>
<section anchor="objstreamdescriptions" title="Media Stream (and Media Stream Track) Descriptions">

<t>RTP is the current standard for performing real-time media transmission. While RTP is effective at media transmission, the RTP transport lacks sufficient details to convert a WebRTC stream object into an RTP transmission and back into an WebRTC stream on the remote peer (where stream objects consist potentially of multiple audio, video (or other) media tracks).</t>

<t>Further, the exact mapping of which sockets and codecs are used is unspecified. RTP does have a SSRC (Synchronization source identifier) for every media stream sent over it which can be used to coordinate the RTP streams. A signaling layer must describe this coordination to be able to synchronize the streams from one peer to another.</t>

<t>Other features, like FEC (Forward Error Correction), are not described in WebRTC stream objects because they are a feature of a transport. Each stream could allow a media track to be sent redundantly on the wire so if part of the stream was damaged during the transmission it could be reconstructed from the redundant stream. Another case is simulcasting where the same media track is encoded multiple ways, for example video layering effects or various encoding sizes (thumbnails vs full streams).</t>

<t>RTP lacks sufficient information to be able to describe FEC or simulcasting as part of its transmission, thus a higher layer must signal this information to a remote peer if these features are to be supported.</t>

<t>The browser must provide a method to create a stream description for the features it supports, to allow for stream and track synchronization (and correlation), and other transport features like FEC or simulcast. The exact mapping structures for the stream must be clearly defined in exacting detail, describing the expected behaviors and use cases a browser must support.</t>

<t>For each track in a stream the browser must supply the following information:</t>

<t><list style='symbols'>
  <t>track-id - the identifier of the track (i.e. from MediaStreamTrack.id <xref target="MediaCapture"/>)</t>
  <t>media-stream-id - the identifier of the associated media stream (i.e. from MediaStream.id <xref target="MediaCapture"/>)</t>
  <t>ssrc - the SSRC of the track as defined by RFC3550 <xref target="RFC3550"/></t>
  <t>kind - the kind of media being transported (meaning derived from MediaStreamTrack <xref target="MediaCapture"/>)</t>
  <t>connection id - the identifier correlating to the connection object (<xref target="objconnection"/>)</t>
  <t>codecs - (optional, the default send / receive codecs capabilities apply if not specified)</t>
</list></t>

<t>If FEC is supported by the browser and the developer’s JavaScript has enabled the feature, the browser must supply the following additional information on FEC tracks:</t>

<t><list style='symbols'>
  <t>the redundancy SSRC - the SSRC that is redundant to the current track</t>
</list></t>

<t>(NOTE: FEC is a complex subject with alternative methods to perform the same levels of redundancy. This draft takes no position on the best techniques and practices and only suggests one method for describing FEC within the steam description. As other description formats are able to support various FEC scenarios, the descriptive information for various FEC scenarios could easily be added into this draft depending on what the IETF/W3C wish to support by default.)</t>

<t>The browser must support a developer’s JavaScript specifying capabilities per track on both the send and receive ends of the track. As each SSRC can be demuxed from other SSRCs at the RTP layer, the capabilities can be applied per track.</t>

<t>While these stream (and track) descriptions are intended to be sent to remote peers, the browser must not mandate the timing, format, or the signaling of these stream descriptions.</t>

<t>Example pseudo-code of how streams could be sent and signaled:</t>

<figure><artwork><![CDATA[
// alice sends information about stream to bob
var aliceStreamDesc = JSON.stringify(
  alice_session.getDescription(aliceMediaStreamToBob));

alice_session.sendStream(aliceMediaStreamToBob);

mysignal("to:bob", JSON.stringify(aliceStreamDesc));

// bob receives stream
var bobMediaStreamFromAlice = new MediaStream();
bob_session.setDescription(
  bobMediaStreamFromAlice,
  JSON.parse(aliceStreamDesc)
  );
bob_connection.receiveStream(bobMediaStreamFromAlice);
]]></artwork></figure>

<section anchor="media-stream-description-expressed-as-a-structure" title="Media Stream Description Expressed as a Structure">

<t>This is an example-only media stream description expressed as a JavaScript structure. This example is not a signaling on-the-wire format mandate.</t>

<figure><artwork><![CDATA[
var myStreamDescription = [
    { // audio
        track: "<track-id>",
        ssrc: 5,
        redundancySsrc: 10,
        connection-id: "<value>",
        capabilities: { /* optional capabilities */ }
    },
    { // video
        kind: "video",
        ssrc: 10,
        connection-id: "<value>",
        capabilities: { /* optional capabilities */ }
     },
     { // dtmf
        kind: "dtmf",
        ssrc: 5,
        connectin-id: "<value>",
        capabilities: { /* optional capabilities */ }
     }
];
]]></artwork></figure>

</section>
</section>
<section anchor="sending-media-streams-over-rtp" title="Sending Media Streams (over RTP)">

<t>The browser must be able to support sending streams via connections <xref target="objconnection"/> over the socket <xref target="objsocket"/>. The developer’s JavaScript must be able to indicate to the browser the stream and track mappings (in the form of a stream description).</t>

<t>The browser must respect the media stream track mapping to the socket <xref target="objsocket"/>, SSRC, and optional capabilities. The “kind” property for sending is merely information but is not explicitly required, but if set, must match the media stream track’s “kind”.</t>

<t>The developer’s JavaScript must be able to control the exact timing when a stream starts to send and when a stream stops sending. At any time, the developer’s JavaScript must be able to change the track mapping and capabilities without the browser imposing any signaling requirements to a remote peer, thus allowing for various alternative signaling scenarios.</t>

<t>The browser must only utilize the codecs within the capabilities provided for sending, and alternate codecs at will. A browser should decide which codec is best suited for the network conditions amongst all the codecs within the capabilities. If a developer’s JavaScript wishes to limit to a particular codec, the capabilities should only contain the codec desired.</t>

<t>If FEC is supported, the browser must coordinate the sending of the FEC RTP redundancy tracks.</t>

</section>
<section anchor="receiving-streams-over-rtp" title="Receiving Streams (over RTP)">

<t>The browser must be able to support receiving streams via connections <xref target="objconnection"/> over the socket <xref target="objsocket"/>. The developer’s JavaScript must be able to specify the streams expectations for any streams about to be received (or currently being received).</t>

<t>The developer’s JavaScript is not required to signal the stream mapping should the developer not care about stream and stream track reassembly, or if the developer will manually assemble the streams tracks into streams based on their own logic. If media tracks arrive without any stream definition, the browser must render the RTP streams as media stream tracks unattached to a particular stream. Should the developer’s JavaScript eventually specify a stream definition, the browser must assemble the individual tracks into streams according to the stream definitions. The developer’s JavaScript must be able to assemble individual stream tracks into streams manually should the developer not wish to provide a stream definition.</t>

<t>The browser must be able to render the same media stream track as part of multiple media stream objects, to allow a stream definition to contain the same track in multiple streams.</t>

<t>Each media stream track is demuxed first by the connection (<xref target="objsocket"/>), then by the SSRC, then by “kind” based upon the codec “kind” of the payload. While technically possible to demux upon the same “kind”, the browser must only support demuxing the same media “kind” with the same SSRC if the payload id used only matches one set of capabilities for a particular track on the receiving stream. A developer’s JavaScript should not mux the same “kind” of media on the same SSRC. A developer’s JavaScript should not mux different “kinds” of media on the same SSRC.</t>

<t>A developer’s JavaScript must provide a stream definition to receive any streams that utilize the FEC feature when transmitting over RTP.</t>

</section>
<section anchor="objdatastreamdescription" title="Data Stream Description">

<t>A data stream is an object that is a specialized type of stream (see <xref target="datastream"/>), just as a media stream is an object for media related information. The data stream description contains the following properties:</t>

<t><list style='symbols'>
  <t>stream id - the identifier for the data stream (from MediaStream.id <xref target="MediaCapture"/>)</t>
  <t>connection id - the connection to carry the data stream (<xref target="objsocket"/>)</t>
</list></t>

<t>The browser must not define or specify how or when the signaling for the data stream description is sent.</t>

</section>
<section anchor="sending-data-streams-over-datasocekt" title="Sending Data Streams (over DataSocekt)">

<t>The browser must be able to send a data stream over the connection. For the simple case, the developer’s JavaScript should be able to send the stream without any additional information being specified to allow for simple signaling scenarios where the data stream mapping is unimportant.</t>

</section>
<section anchor="receiving-data-streams-over-datasocket" title="Receiving Data Streams (over DataSocket)">

<t>In the receive direction, the browser must be able to open a data stream based upon the data stream description information from the remote peer. The browser should support a method to fetch the next available data stream without needing any specifier to handle simple signaling scenarios where specific stream mappings are unimportant.</t>

</section>
</section>
<section anchor="objfeaturediscovery" title="RTC Feature Discovery">

<t>The browser must have a method to allow a developer’s JavaScript to determine what RTP features are available from the browser’s RTC engine without performing browser and browser version detection. While some features can be probed by way of checking if an object exists to support the feature, other features cannot. For example; the developer’s JavaScript should be able to probe the browser to answer “Does the RTC engine support FEC?”</t>

<t>At minimum, each feature only needs to be a well defined standardized string that determines the exact expectations, feature sets and behaviors that are supported by the browser’s RTC engine. Should the browsers define custom extension features, the browser must namespace each feature in such a way to avoid non-standard features from conflicting with a potential future standardized definition.</t>

<t>RTC features can be vast and complex. Having a feature discovery is especially important to allow for a variety of implementations without setting the requirements bar too high on browser implementations. Developers also need a method to ensure (through JavaScript) they can detect which options are available to remain compatible. Performing unreliable browser probing techniques is not sufficient. Many RTC features are hidden behind complex rules in the engine and cannot be probed easily, for example, FEC.</t>

</section>
<section anchor="dtmf" title="Example: DTMFMediaStreamTrack Specialization">

<t>One of the use case requirements in Web Real-Time Communication Use-cases and Requirements is DTMF navigation of IVR systems <xref target="I-D.ietf-rtcweb-use-cases-and-requirements"/>. Typically DTMF is performed by transmitting RTP data as described in RFC 4733 <xref target="RFC4733"/>.</t>

<t>One possible method to implement a DTMF data stream is by specialization of the media stream track. The stream description (<xref target="objstreamdescriptions"/>) does allow for mapping a track to an RTP mapping and DTMF does not require any special mapping, except ensuring the DTMF track shares the same SSRC as an audio track. The browser should create reasonable rules to auto-pair a DTMF stream track to an audio track for a stream description.</t>

<t>The browser engine must interpret signals given from the DTMF stream to override the audio stream to send DTMF packets as described in RFC 4733. The browser must define a special codec for DTMF with a kind defined as “dtmf”.</t>

<t>Should the decision to interpret incoming DTMF tones be mandated by the RTCWEB WG then the browser should interpret received DTMF tones received as per RFC 4733 and fire events that a developer’s JavaScript can intercept. For a use case example, as browser engines are being embedded in other technologies, such as Node.js, having the browser be capable of interpreting DTMF signals may allow for JavaScript server based IVR style-system when bundled with a relevant signal protocol.</t>

</section>
<section anchor="datastream" title="Example: DataStream Specialization">

<t>A data stream object can be a specialized type of stream, just as media stream is used for sending media data. Data streams allow data to be transmitted over a data compatible socket (<xref target="objsocket"/>), such as DTLS/SCTP <xref target="RFC6347"/>/<xref target="RFC4960"/>. A data stream is a bi-direction stream allowing for each peer to send and receive data over the same data stream.</t>

<t>To open a data stream, one peer must initiate the stream through a browser supplied send method, and another peer must be able to receive an event in JavaScript about the new incoming data stream. The developer’s JavaScript must be able to start receive data stream events for any sent data. Both peers via JavaScript must be able to send data to the other and receive data stream events.</t>

</section>
</section>
<section anchor="signaling-models" title="Signaling Models">

<section anchor="sdp-with-offer-answer" title="SDP with Offer / Answer">

<t>While it could be said that the current WebRTC 1.0 API <xref target="WebRTC10"/> is best suited for SDP / SIP, that might not be the case. Many SIP networks have a large investment in their SIP infrastructures and technology, and updating all of their technology is not simple. If what the browser produces for SDP is not 100% compatible, they must either convert to SDPs from the browser via JavaScript to SDPs that are compatible, or introduce other gateways that do the conversion. By removing SDP from the browser, this allows the SIP vendors to generate SDP specifically tailored to their SIP network, and more easily control the exact conditions in the browser they need to be compatible.</t>

<t>In other words, one could argue that SDP / SIP developers wouldn’t need to do extra work to be compatible with the browsers, but for many, that simply might not be true. Having SDP generated in the browser allows a SIP network provider less control over what SDP is produced than having JavaScript produce the SDP as a dynamically updated downloaded module where all browsers produce the identical SDP. To explore this reasoning further please see the related rationale draft <xref target="I-D.raymond-rtcweb-webrtc-js-obj-api-rationale"/>.</t>

<t>This section will outline how JavaScript can generate an SDP from basic descriptions, just as an SDP parser can reconstruct the information each object’s description requires. Yet these SDPs that are produced are custom tailored with exact specifications yielding greater compatibility than relying upon each browser to produce identical SDPs.</t>

<section anchor="constructing-an-offer" title="Constructing an Offer">

<t>The first step required is creating a connection object. The connection object can optionally be constructed with various socket configurations for transport, such as separating audio and video RTP sockets, or muxing the data on the same socket as RTP. The developer can obtain the send capabilities and populate the “m=” line(s) for the media desired, as well as all the codec information. The ice userFrag and password information is available from the connection object. If the SDP must generate SSRC mappings, the “getDescription” method can be used to obtain the mapping information in order to generate the various SDP SSRC entries accordingly. Finally, the ICE candidates will be notified using an “onconnectioncandidate” event and the offer can either be generated before all candidates arrive, or after once all candidates are ready.</t>

<t>The peer can be put into an “offer” state.</t>

</section>
<section anchor="parsing-an-offer" title="Parsing an Offer">

<t>When a remote peer receives an offer, the peer must construct an answer, but it must parse the offer before this. The first step is to parse out the SDP information as per the expectations of how it was generated. Since the offer was constructed with JavaScript and not by the browser, the exact parameters and fields will be exactly how the JavaScript decided with no surprises (outside of fixable JavaScript bugs). The remote peer can construct a connection object in the same manner as the offer peer. The SDP is extracted for its ICE credentials, where “setDescription” is called for the connection with the relevant information from the offer about the ICE userFrag, password and the ICE candidates can be set using “setRemoteConnectionCandidate”. The codecs are pulled from the SDP and “setCapabilities” is called to indicate the “receive” capabilities. If SSRC mapping was supported, the SSRC maps can be pulled out of the SDP and set using “setDescription” with a “receive” stream object provided.</t>

</section>
<section anchor="generating-an-answer" title="Generating an Answer">

<t>To construct answer, the ICE credentials are pulled from the connection object using the “getDescription”. The candidates will arrive on the “onconnectioncandidate” and can be placed in the SDP. The capabilities for the “send” can be obtained by calling “getCapabilities” for the “send” direction (and only mutually agreed codecs can be filtered in if desired). The “m=” line can be generated for the specific medias with the related “a=” codec mappings. If the SDP must generate SSRC mappings, the “getDescription” method can be used to obtain the mapping information in order to generate the various SDP SSRC entries in the answer.</t>

<t>The remote peer can be put into the “negotiated” state.</t>

</section>
<section anchor="parsing-an-answer" title="Parsing an Answer">

<t>When a peer in the offer state receives an answer, the peer must parse the answer. The first step is to parse out the SDP information as per the expectations of how it was generated. Since the offer was constructed with JavaScript and not by the browser, the exact parameters and fields will be exactly how the JavaScript decided with no surprises (outside of fixable JavaScript bugs). The peer has a connection object already. The SDP is extracted for its ICE credentials, where “setDescription” is called for the connection with the relevant information from the answer about the ICE userFrag, password and the ICE candidates can be set using “setRemoteConnectionCandidate”. The codecs are pulled from the SDP and “setCapabilities” is called to indicate the “receive” capabilities. If SSRC mapping was supported, the SSRC maps can be pulled out of the SDP and set using “setDescription” with a “receive” stream object provided.</t>

<t>The peer can be put into the “negotiated” state.</t>

</section>
<section anchor="use-of-provisional-answers" title="Use of Provisional Answers">

<t>In the object model, any connection can be forked (<xref target="interactionforking"/>) at any time by reusing the same socket object. If a provisional answer is needed as another answer has arrived from an offer, the developer only need only create a new connection object. The developer will then have a connection which can be independently managed with a unique set of ICE candidates, capabilities, and streams. Each connection is its own object and thus allows for independent negotiation with each forked offer which receives an answer.</t>

</section>
<section anchor="rollback" title="Rollback">

<t>As all the descriptions and capabilities for each object can be maintained easily in an offer / answer state machine, the state machine can obtain all this information prior to constructing a new offer with new information. If the offer is rejected, the state can be rolled back to the previous state immediately, or, alternatively a new state can be applied only when an offer has been accepted. The browser does not need to know the state machine or the previous states, as all of this information can easily be set from JavaScript.</t>

</section>
<section anchor="configurable-sdp-parameters" title="Configurable SDP Parameters">

<t>Many SIP providers have custom SDP options and extensions. By allowing the SDP to be generated by JavaScript, the SDP extensions can be placed inside the SDP, without petitioning the browser vendor to make a change.</t>

</section>
<section anchor="sdp-offer-answer-state-machine-in-js" title="SDP Offer / Answer State Machine in JS">

<t>There is nothing special about an offer / answer state machine. The state machine can just as easily be defined in JavaScript as it can by the browser’s internal language. The difference is that fixes in the state machine with JavaScript can be applied dynamically whereas fixes to mistakes in the browser’s state machine are impossible until a browser update is released. At best a mistake in the browser can be “worked around”. JavaScript can be made to follow the same rules, requirements and expectations as native code, except it becomes optional for JavaScript developers, rather than mandating the state machine be followed for all signaling protocols (even those that do not want offer / answer).</t>

</section>
</section>
<section anchor="one-side-capabilities" title="One-side Capabilities">

<t>Another model for negotiation is “one-sided” capabilities negotiation. In this model, each peer derives a set of “receive” capabilities, which are set to the remote peer. Each peer is allowed to update their respective “receive” capabilities at any time, which must be adhered by the remote party. This is useful to be able to send streams at will without requiring constant back and forth “offer”, “answer’ and “negotiated” states.</t>

<t>To perform this model, each side obtains its “receive” capabilities using “getCapabilities” on the “receive” direction. The capabilities information is then mutually exchanged as needed. The ICE candidate information is only exchanged upon start and the session lasts for the lifetime of the connection. Imposing a state machine like offer / answer hampers the simplicity of this signaling model. Whereas, SDP requires that the offer and answer contain the “send” capabilities and not the “receive” capabilities. To make this work with offer / answer and SDP requires a fair amount of SDP jerry-rigging (see <xref target="WebRTCJSObjExamples"/> for an example).</t>

<t>Example pseudo-code of how capabilities could be re-signaled:</t>

<figure><artwork><![CDATA[
// alice changes capabilities locally
var myCapabilities = internalChangeCapabilities();
alice_session.setCapabilities(myCapabilities, "receive");

// alice signals changed capabilities to bob
var sigCapabilities = JSON.stringify(
  alice_session.getCapabilities("receive"));
mysignal(sigCapabilities);

// bob changes sending capabilities
bob_session.setCapabilities(JSON.parse(sigCapabilities), "send");
]]></artwork></figure>

</section>
<section anchor="xmpp" title="XMPP">

<t>XMPP using Jingle <xref target="Jingle"/> as a signaling mechanism. XMPP requires no SDP at all and uses XML as the mechanism for expressing capabilities. By allowing XMPP to directly obtain structured data in JavaScript as well as direct control over the objects without imposing signaling mandates, XMPP implementations are free of the burden imposed with parsing and generating an unfamiliar SDP format, or adhering to the SIP definition of offer / answer, rather than adhering to the Jingle state machine.</t>

</section>
<section anchor="interactionforking" title="Interactions With Forking">

<t>Some signaling scenarios allow forking. With forking, an offer for a connection is made, but multiple peers might answer to the request to connect. For example, Alice might call Bob but Bob has two devices so both of Bob’s devices might answer. The answers can arrive at any time after the offer to connect request has been made. For example, SIP <xref target="RFC3261"/> defines “Parallel Search”, as well as “Sequential Search”. The browser must support forking by allowing a connection object to become forked at any time. This allows each connection to share common ICE userFrag and password credentials with the capabilities defaulted identically, but each fork is allowed to negotiate its own ICE candidates, capabilities, connection and stream descriptions. By doing so, the JavaScript developer can fully support signaling protocols where the forking is allowed, such as SIP.</t>

<section anchor="sequentialforking" title="Sequential Forking">

<t>As the offer / answer state machine is not imposed on a WebRTC JavaScript object model, there is no need to provide provisional answers in the state machine. A provisional answer is an answer that is temporarily accepted until the final answer is determined. Each answer has it’s own fork, and the various forks can be handled independently. Once the final sequential answer arrives, all the other connections can be disconnected.</t>

</section>
<section anchor="parallelforking" title="Parallel Forking">

<t>As the offer / answer state machine is not imposed on a WebRTC JavaScript object model, and forking is supported, parallel forking is also supported. Each answer has it’s own fork, and the various forks can be managed independently. There is no need to disconnect any fork, and each connections’ capabilities, descriptions, streams and lifetime is entirely in the control of the JavaScript application.</t>

</section>
</section>
<section anchor="session-rehydration" title="Session Rehydration">

<t>The JSEP draft <xref target="I-D.ietf-rtcweb-jsep"/> described session rehydration as follows:
“In the event that the local application state is reinitialized, either due to a user reload of the page, or a decision within the application to reload itself (perhaps to update to a new version), it is possible to keep an existing session alive, via a process called “rehydration”.  The explicit goal of rehydration is to carry out this session resumption with no interaction with the remote side other than normal call signaling messages.”</t>

<t>In order for rehydration to work the current state of the connections must persist somewhere outside of the browser page’s context. To support reydration, a developer’s JavaScript must be capable of re-creating the stream and connection objects as per the previous persisted state, including but not limited to, all candidate negotiations, all connection establishments, all active streams and the relationships between streams, connections and sockets.</t>

<t>Further, the browser must maintain a reasonable lifetime for which JavaScript is allowed to reconnect to these objects with appropriate security precautions to ensure the objects cannot be hijacked by an unauthorized page containing malicious JavaScript.</t>

<t>The exact mechanism and API for these near-death object resurrections falls within the scope of the W3C and does not impact the overall concepts and design described in this draft, as long as the browser allows the RTC objects to be resurrected exactly in their previous states prior to a page reload, and JavaScript security tenants are adhered.</t>

</section>
</section>
<section anchor="comparison-to-other-approaches" title="Comparison to Other Approaches">

<section anchor="jsep" title="JSEP">

<t>The main differences in the WebRTC Object vs JSEP:</t>

<t><list style='numbers'>
  <t>JSEP requires an all-encompassing complete description of media, transports, capabilities and streams.</t>
  <t>Enforces an offer / answer state machine upon all signaling.</t>
  <t>Enforces SDP offer / answer negotiation.</t>
  <t>Requires other signaling protocols to transcode from an unfamiliar SDP format.</t>
  <t>Offers little granular control over the contents of the SDP.</t>
  <t>Allows simple WebRTC scenarios to be easily implemented.</t>
  <t>Has a free format where behavior expectations for future additions are unknown, or what aspects of the SDP are allowed to be manipulated or not.</t>
  <t>Allows SIP implementations to interface with the browser.</t>
</list></t>

<t>Where as WebRTC JavaScript Object Model:</t>

<t><list style='numbers'>
  <t>Modularizes the information needed into independent components.</t>
  <t>Enforces no signaling mandates, other than candidate connectivity checking.</t>
  <t>Treats capabilities as independent and updateable as signaling protocols might require.</t>
  <t>Allows JavaScript developers to utilize well known JavaScript structures to obtain information.</t>
  <t>Exposes all the content in a granular fashion.</t>
  <t>Allows simple WebRTC scenarios to be easily implemented.</t>
  <t>Has strict rules as to what information is allowed for each object, and methods / events have testable compliance behaviors that can be established.</t>
  <t>Allows SIP implementations to interface with the browser with more predictable behaviors.</t>
</list></t>

<t>Overall, the WebRTC JavaScript Object Model is more flexible but maintains the same ease of use for basic use cases.</t>

</section>
<section anchor="plana-or-planb" title="PlanA or PlanB">

<t>Plan A <xref target="I-D.roach-rtcweb-plan-a"/>, Plan B <xref target="I-D.uberti-rtcweb-plan"/>, and NoPlan <xref target="I-D.ivov-rtcweb-noplan"/> are all methods for dealing with large number of media streams and how they must be expressly described in SDP, or negotiated along side SDP. Each have their own merits and pitfalls. However, since this is SDP / SIP specific the RTCWEB WG does not need to be involved in these discussions. All three of these models can be expressed in an object model, and should any additional description information be needed, the object model can be extended to accommodate accordingly.</t>

</section>
<section anchor="noplan" title="NoPlan">

<t>NoPlan is a hybrid approach where some information is carried over SDP, the SDP offer / answer state machine still applies but many of the other description information exists outside the SDP. While a step in the right direction, this creates a lot of ambiguity for responsibilities as well as what should be adhered and what should not. More importantly, the ambiguity exists for extensions. Are they part of SDP, or not? Had NoPlan been taken to the full extent to replace SDP and offer / answer, this solution would be best. In many ways, this is what the object model proposed in this draft is doing.</t>

</section>
</section>
<section anchor="requirements-compliance-statement" title="Requirements Compliance Statement">

<t>This draft is compliant to the following relevant requirements specified in Web Real-Time Communication Use-cases and Requirements <xref target="I-D.ietf-rtcweb-use-cases-and-requirements"/>:</t>

<t><list style='symbols'>
  <t>F2, F3, F4, F10, F11, F12, F16, F19, F20, F22, F25, F26, F27, F29, F31, F32, F33, F35, F36, F37, F38, F39</t>
</list></t>

<t>Whereas the following requirements are not applicable to this draft (either exist outside the object model or are an internal feature of an internal RTC engine):</t>

<t><list style='symbols'>
  <t>F1, F5, F7, F8, F9, F13, F14, F15, F17, F18, F21, F23, F24, F28, F30, F34</t>
</list></t>

<t>Appropriate design consideration was given to the relevant sections in the “Web Real-Time Communication (WebRTC) - Media Transport and Use of RTP <xref target="I-D.ietf-rtcweb-rtp-usage"/>” draft.</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>As stated best in JSEP draft <xref target="I-D.ietf-rtcweb-jsep"/> in the security considerations section “The intent of the WebRTC protocol suite is to provide an environment that is securable by default: all media is encrypted, keys are exchanged in a secure fashion, and the Javascript API includes functions that can be used to verify the identity of communication partners.”</t>

<section anchor="dtls" title="DTLS">

<section anchor="fingerprintresponsibility" title="DTLS Fingerprint Responsibility">

<t>When DTLS <xref target="RFC6347"/> is used for a connection (<xref target="objconnection"/>), the DTLS fingerprint(s) must be signaled by the developer in such a way that the hash cannot be modified during transit between connecting peers during a signaling exchange, and / or alternatively, the ownership of the fingerprint(s) must be cryptographically proven to correlate to the identity of the connected peer. Failure to perform a secure exchange of fingerprint(s) or a correlation of the fingerprint(s) to the remote peer’s identity may result in a compromised DTLS channel. The responsibility for ensuring a non-compromised DTLS channel fingerprint must be left to the JavaScript developer and signaling path to handle.</t>

<t>The browser must expose the fingerprints involved from the Connection <xref target="objconnection"/> object and from each socket that uses DTLS <xref target="objsocket"/>.</t>

</section>
<section anchor="idp" title="IdP">

<t>The identity provider model (IdP) should not be mandated. This allows the IdP draft to become perfected until it is ready for usage and all scenarios and usages of IdP have been thoroughly thought through. Regardless, IdP should not be mandated. Not all WebRTC servers have an identity model for their users.</t>

<t>The IdP model is far from completion at the time of this draft. The current model requires round trips to perform validation before a stream can be rendered, which is not desirable. In simple use cases, the IdP model is not required as a WebSocket with TLS can be used to exchange fingerprints for a private service, which provides the same level of trust from a provider as IdP since the fingerprints are exchanged in a private and secure manner via a trusted provider. The complexity of any identity model must be factored, especially in consideration basic and simple WebRTC use cases.</t>

<t>Should IdP becomes perfected, the connection description <xref target="objconnectiondescription"/> can be extended to include the identity information as part of connection negotiation.</t>

</section>
<section anchor="dtlssrtp" title="DTLS / SRTP vs SDES / SRTP">

<t>Auto-keying for SRTP must be done through a DTLS handshakes extensions as opposed to requiring SDES <xref target="RFC4568"/>. DTLS must have a foolproof man-in-the-middle attack prevention scheme (i.e. fingerprint validation, see <xref target="idp"/>). Without the fingerprint validation, little security is provided should the stream be intercepted.</t>

<t>If substantial push-back exists over mandating the usage of DTLS for keying over SDES, then the keying for SDES can be easily be included as part of the capabilities structure <xref target="objcapabilities"/>. The final decision to mandate, recommend or allow for media key negotiation over DTLS must be made by the RTCWEB WG before any RTC JavaScript interface can be completed.</t>

</section>
</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>This document requires no actions from IANA.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='I-D.ietf-rtcweb-use-cases-and-requirements'>
<front>
<title>Web Real-Time Communication Use-cases and Requirements</title>

<author initials='C' surname='Holmberg' fullname='Christer Holmberg'>
    <organization />
</author>

<author initials='S' surname='Hakansson' fullname='Stefan Hakansson'>
    <organization />
</author>

<author initials='G' surname='Eriksson' fullname='Goran Eriksson'>
    <organization />
</author>

<date month='June' day='27' year='2013' />

<abstract><t>This document describes web based real-time communication use-cases. Requirements on the browser functionality are derived from use-cases.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-rtcweb-use-cases-and-requirements-11' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-rtcweb-use-cases-and-requirements-11.txt' />
</reference>



<reference anchor='I-D.ietf-rtcweb-rtp-usage'>
<front>
<title>Web Real-Time Communication (WebRTC): Media Transport and Use of RTP</title>

<author initials='C' surname='Perkins' fullname='Colin Perkins'>
    <organization />
</author>

<author initials='M' surname='Westerlund' fullname='Magnus Westerlund'>
    <organization />
</author>

<author initials='J' surname='Ott' fullname='Joerg Ott'>
    <organization />
</author>

<date month='July' day='15' year='2013' />

<abstract><t>The Web Real-Time Communication (WebRTC) framework provides support for direct interactive rich communication using audio, video, text, collaboration, games, etc.  between two peers' web-browsers.  This memo describes the media transport aspects of the WebRTC framework. It specifies how the Real-time Transport Protocol (RTP) is used in the WebRTC context, and gives requirements for which RTP features, profiles, and extensions need to be supported.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-rtcweb-rtp-usage-07' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-rtcweb-rtp-usage-07.txt' />
</reference>



<reference anchor='RFC3550'>

<front>
<title>RTP: A Transport Protocol for Real-Time Applications</title>
<author initials='H.' surname='Schulzrinne' fullname='H. Schulzrinne'>
<organization /></author>
<author initials='S.' surname='Casner' fullname='S. Casner'>
<organization /></author>
<author initials='R.' surname='Frederick' fullname='R. Frederick'>
<organization /></author>
<author initials='V.' surname='Jacobson' fullname='V. Jacobson'>
<organization /></author>
<date year='2003' month='July' />
<abstract>
<t>This memorandum describes RTP, the real-time transport protocol.  RTP provides end-to-end network transport functions suitable for applications transmitting real-time data, such as audio, video or simulation data, over multicast or unicast network services.  RTP does not address resource reservation and does not guarantee quality-of- service for real-time services.  The data transport is augmented by a control protocol (RTCP) to allow monitoring of the data delivery in a manner scalable to large multicast networks, and to provide minimal control and identification functionality.  RTP and RTCP are designed to be independent of the underlying transport and network layers.  The protocol supports the use of RTP-level translators and mixers.  Most of the text in this memorandum is identical to RFC 1889 which it obsoletes.  There are no changes in the packet formats on the wire, only changes to the rules and algorithms governing how the protocol is used.  The biggest change is an enhancement to the scalable timer algorithm for calculating when to send RTCP packets in order to minimize transmission in excess of the intended rate when many participants join a session simultaneously. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='STD' value='64' />
<seriesInfo name='RFC' value='3550' />
<format type='TXT' octets='259985' target='http://www.rfc-editor.org/rfc/rfc3550.txt' />
<format type='PS' octets='630740' target='http://www.rfc-editor.org/rfc/rfc3550.ps' />
<format type='PDF' octets='504117' target='http://www.rfc-editor.org/rfc/rfc3550.pdf' />
</reference>



<reference anchor='RFC5245'>

<front>
<title>Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols</title>
<author initials='J.' surname='Rosenberg' fullname='J. Rosenberg'>
<organization /></author>
<date year='2010' month='April' />
<abstract>
<t>This document describes a protocol for Network Address Translator (NAT) traversal for UDP-based multimedia sessions established with the offer/answer model.  This protocol is called Interactive Connectivity Establishment (ICE).  ICE makes use of the Session Traversal Utilities for NAT (STUN) protocol and its extension, Traversal Using Relay NAT (TURN).  ICE can be used by any protocol utilizing the offer/answer model, such as the Session Initiation Protocol (SIP). [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5245' />
<format type='TXT' octets='285120' target='http://www.rfc-editor.org/rfc/rfc5245.txt' />
</reference>



<reference anchor='I-D.rescorla-mmusic-ice-trickle'>
<front>
<title>Trickle ICE: Incremental Provisioning of Candidates for the Interactive Connectivity Establishment (ICE) Protocol</title>

<author initials='E' surname='Rescorla' fullname='Eric Rescorla'>
    <organization />
</author>

<author initials='J' surname='Uberti' fullname='Justin Uberti'>
    <organization />
</author>

<author initials='E' surname='Ivov' fullname='Emil Ivov'>
    <organization />
</author>

<date month='October' day='22' year='2012' />

<abstract><t>This document describes an extension to the Interactive Connectivity Establishment (ICE) protocol that allows ICE agents to send and receive candidates incrementally rather than exchanging complete lists.  With such incremental provisioning, ICE agents can begin connectivity checks while they are still gathering candidates and considerably shorten the time necessary for ICE processing to complete.  The above mechanism is also referred to as "trickle ICE".</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-rescorla-mmusic-ice-trickle-01' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-rescorla-mmusic-ice-trickle-01.txt' />
</reference>


<reference anchor="MediaStreams" target="http://www.w3.org/TR/2013/WD-mediacapture-streams-20130516/">
  <front>
    <title>Media Capture and Streams</title>
    <author initials="D." surname="Burnett" fullname="Daniel C. Burnett">
      <organization></organization>
    </author>
    <date year="2013" month="March" day="16"/>
  </front>
</reference>


    </references>

    <references title='Informative References'>





<reference anchor='I-D.ietf-rtcweb-jsep'>
<front>
<title>Javascript Session Establishment Protocol</title>

<author initials='J' surname='Uberti' fullname='Justin Uberti'>
    <organization />
</author>

<author initials='C' surname='Jennings' fullname='Cullen Jennings'>
    <organization />
</author>

<date month='February' day='27' year='2013' />

<abstract><t>This document describes the mechanisms for allowing a Javascript application to fully control the signaling plane of a multimedia session via the interface specified in the W3C RTCPeerConnection API, and discusses how this relates to existing signaling protocols.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-rtcweb-jsep-03' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-rtcweb-jsep-03.txt' />
</reference>



<reference anchor='I-D.jesup-rtcweb-data-protocol'>
<front>
<title>WebRTC Data Channel Protocol</title>

<author initials='R' surname='Jesup' fullname='Randell Jesup'>
    <organization />
</author>

<author initials='S' surname='Loreto' fullname='Salvatore Loreto'>
    <organization />
</author>

<author initials='M' surname='Tuexen' fullname='Michael Tuexen'>
    <organization />
</author>

<date month='February' day='26' year='2013' />

<abstract><t>The Web Real-Time Communication (WebRTC) working group is charged to provide protocols to support for direct interactive rich communication using audio, video, and data between two peers' web- browsers.  This document specifies an actual (minor) protocol for how the JS-layer DataChannel objects provide the data channels between the peers.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-jesup-rtcweb-data-protocol-04' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-jesup-rtcweb-data-protocol-04.txt' />
</reference>



<reference anchor='I-D.raymond-rtcweb-webrtc-js-obj-api-rationale'>
<front>
<title>WebRTC JavaScript Object API Rationale</title>

<author initials='R' surname='Raymond' fullname='Robin Raymond'>
    <organization />
</author>

<author initials='E' surname='Lagerway' fullname='Erik Lagerway'>
    <organization />
</author>

<author initials='I' surname='Castillo' fullname='Inaki Castillo'>
    <organization />
</author>

<author initials='R' surname='Shpount' fullname='Roman Shpount'>
    <organization />
</author>

<date month='July' day='6' year='2013' />

<abstract><t>This document describes the reasons why a JavaScript Object Model approach is a far better solution than using SDP [RFC4566] as a surface API for interfacing with WebRTC.  The document outlines the issues and pitfalls as well as use cases that are difficult (or impossible) with SDP with offer / answer [RFC3264], and explains the benefits and goals of an alternative JavaScript object model approach.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-raymond-rtcweb-webrtc-js-obj-api-rationale-01' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-raymond-rtcweb-webrtc-js-obj-api-rationale-01.txt' />
</reference>



<reference anchor='I-D.ietf-avtcore-6222bis'>
<front>
<title>Guidelines for Choosing RTP Control Protocol (RTCP) Canonical Names (CNAMEs)</title>

<author initials='A' surname='Begen' fullname='Ali Begen'>
    <organization />
</author>

<author initials='C' surname='Perkins' fullname='Colin Perkins'>
    <organization />
</author>

<author initials='D' surname='Wing' fullname='Dan Wing'>
    <organization />
</author>

<author initials='E' surname='Rescorla' fullname='Eric Rescorla'>
    <organization />
</author>

<date month='July' day='14' year='2013' />

<abstract><t>The RTP Control Protocol (RTCP) Canonical Name (CNAME) is a persistent transport-level identifier for an RTP endpoint.  While the Synchronization Source (SSRC) identifier of an RTP endpoint may change if a collision is detected or when the RTP application is restarted, its RTCP CNAME is meant to stay unchanged, so that RTP endpoints can be uniquely identified and associated with their RTP media streams.  For proper functionality, RTCP CNAMEs should be unique within the participants of an RTP session.  However, the existing guidelines for choosing the RTCP CNAME provided in the RTP standard are insufficient to achieve this uniqueness.  RFC 6222 was published to update those guidelines to allow endpoints to choose unique RTCP CNAMEs. Unfortunately, later investigations showed that some parts of the new algorithms were unnecessarily complicated and/or ineffective.  This document addresses these concerns and replaces RFC 6222.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-avtcore-6222bis-06' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-avtcore-6222bis-06.txt' />
</reference>



<reference anchor='I-D.ietf-mmusic-sdpng'>
<front>
<title>Session Description and Capability Negotiation</title>

<author initials='D' surname='Kutscher' fullname='Dirk Kutscher'>
    <organization />
</author>

<author initials='J' surname='Ott' fullname='Joerg Ott'>
    <organization />
</author>

<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>

<date month='February' day='23' year='2005' />

<abstract><t>This document defines a language for describing multimedia sessions with respect to configuration parameters and capabilities of end-systems. The description language is independent of specific application scenarios (session announcement, session setup for interactive communication etc.) and is not limited to specific media types, capabilities, or configuration parameters.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-mmusic-sdpng-08' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-mmusic-sdpng-08.txt' />
</reference>



<reference anchor='I-D.roach-rtcweb-plan-a'>
<front>
<title>Using SDP with Large Numbers of Media Flows</title>

<author initials='A' surname='Roach' fullname='Adam Roach'>
    <organization />
</author>

<author initials='M' surname='Thomson' fullname='Martin Thomson'>
    <organization />
</author>

<date month='May' day='7' year='2013' />

<abstract><t>A recurrent theme in WebRTC has been the need to handle very large numbers of media flows.  Unfortunately, naive uses of SDP do not handle this case particularly well.  This document describes a modest set of extensions to SDP which allow it to cleanly handle arbitrary numbers of flows while still retaining a large degree of backward compatibility with existing and non-RTCWEB endpoints.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-roach-rtcweb-plan-a-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-roach-rtcweb-plan-a-00.txt' />
</reference>



<reference anchor='I-D.uberti-rtcweb-plan'>
<front>
<title>Plan B: a proposal for signaling multiple media sources in WebRTC.</title>

<author initials='J' surname='Uberti' fullname='Justin Uberti'>
    <organization />
</author>

<date month='May' day='2' year='2013' />

<abstract><t>This document explains how multiple media sources can be signaled in WebRTC using SDP, in a fashion that avoids many common problems and provides a simple control surface to the receiver.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-uberti-rtcweb-plan-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-uberti-rtcweb-plan-00.txt' />
</reference>



<reference anchor='I-D.ivov-rtcweb-noplan'>
<front>
<title>No Plan: Economical Use of the Offer/Answer Model in WebRTC Sessions with Multiple Media Sources</title>

<author initials='E' surname='Ivov' fullname='Emil Ivov'>
    <organization />
</author>

<author initials='E' surname='Marocco' fullname='Enrico Marocco'>
    <organization />
</author>

<author initials='P' surname='Thatcher' fullname='Peter Thatcher'>
    <organization />
</author>

<date month='June' day='17' year='2013' />

<abstract><t>This document describes a model for the lightweight use of SDP Offer/ Answer in WebRTC.  The goal is to minimize reliance on Offer/Answer exchanges in a WebRTC session and provide applications with the tools necessary to implement the signalling that they may need in a way that best fits their custom requirements and topologies.  This simplifies signalling of multiple media sources or providing RTP Synchronisation source (SSRC) identification in multi-party sessions. Another important goal of this model is to remove from clients topological constraints such as the requirement to know in advance all SSRC identifiers that they could potentially introduce in a particular session.  The model described here is similar to the one employed by the data channel JavaScript APIs in WebRTC, where methods are supported on PeerConnection without being reflected in SDP.  This document does not question the use of SDP and the Offer/Answer model or the value they have in terms of interoperability with legacy or other non-WebRTC devices.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ivov-rtcweb-noplan-01' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ivov-rtcweb-noplan-01.txt' />
</reference>


<reference anchor="WebRTC10" target="http://www.w3.org/TR/2012/WD-webrtc-20120821/">
  <front>
    <title>WebRTC 1.0 Real-time Communication Between Browsers</title>
    <author initials="A." surname="Bergkvist" fullname="Adam Bergkvist">
      <organization></organization>
    </author>
    <date year="2012" month="August" day="21"/>
  </front>
</reference>
<reference anchor="MediaCapture" target="http://www.w3.org/TR/2013/WD-mediacapture-streams-20130516/">
  <front>
    <title>Media Capture and Streams</title>
    <author initials="D." surname="Burnett" fullname="Daniel C. Burnett">
      <organization></organization>
    </author>
    <date year="2013" month="May" day="29"/>
  </front>
</reference>
<reference anchor="WebRTCJSObjExamples" target="http://tools.ietf.org/html/draft-raymond-rtcweb-webrtc-js-obj-rtc-examples-00">
  <front>
    <title>WebRTC JavaScript Object RTC Examples</title>
    <author initials="R." surname="Raymond" fullname="Robin Raymond">
      <organization></organization>
    </author>
    <date year="2013" month="July" day="05"/>
  </front>
</reference>
<reference anchor="Jingle" target="http://xmpp.org/extensions/xep-0166.html">
  <front>
    <title>XEP-0166 Jingle</title>
    <author initials="." surname="XMPP Standards Foundation" fullname="XMPP Standards Foundation">
      <organization></organization>
    </author>
    <date year="2009" month="December" day="23"/>
  </front>
</reference>




<reference anchor='RFC3261'>

<front>
<title>SIP: Session Initiation Protocol</title>
<author initials='J.' surname='Rosenberg' fullname='J. Rosenberg'>
<organization /></author>
<author initials='H.' surname='Schulzrinne' fullname='H. Schulzrinne'>
<organization /></author>
<author initials='G.' surname='Camarillo' fullname='G. Camarillo'>
<organization /></author>
<author initials='A.' surname='Johnston' fullname='A. Johnston'>
<organization /></author>
<author initials='J.' surname='Peterson' fullname='J. Peterson'>
<organization /></author>
<author initials='R.' surname='Sparks' fullname='R. Sparks'>
<organization /></author>
<author initials='M.' surname='Handley' fullname='M. Handley'>
<organization /></author>
<author initials='E.' surname='Schooler' fullname='E. Schooler'>
<organization /></author>
<date year='2002' month='June' />
<abstract>
<t>This document describes Session Initiation Protocol (SIP), an application-layer control (signaling) protocol for creating, modifying, and terminating sessions with one or more participants.  These sessions include Internet telephone calls, multimedia distribution, and multimedia conferences. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='3261' />
<format type='TXT' octets='647976' target='http://www.rfc-editor.org/rfc/rfc3261.txt' />
</reference>



<reference anchor='RFC4566'>

<front>
<title>SDP: Session Description Protocol</title>
<author initials='M.' surname='Handley' fullname='M. Handley'>
<organization /></author>
<author initials='V.' surname='Jacobson' fullname='V. Jacobson'>
<organization /></author>
<author initials='C.' surname='Perkins' fullname='C. Perkins'>
<organization /></author>
<date year='2006' month='July' />
<abstract>
<t>This memo defines the Session Description Protocol (SDP).  SDP is intended for describing multimedia sessions for the purposes of session announcement, session invitation, and other forms of multimedia session initiation. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4566' />
<format type='TXT' octets='108820' target='http://www.rfc-editor.org/rfc/rfc4566.txt' />
</reference>



<reference anchor='RFC3264'>

<front>
<title>An Offer/Answer Model with Session Description Protocol (SDP)</title>
<author initials='J.' surname='Rosenberg' fullname='J. Rosenberg'>
<organization /></author>
<author initials='H.' surname='Schulzrinne' fullname='H. Schulzrinne'>
<organization /></author>
<date year='2002' month='June' />
<abstract>
<t>This document defines a mechanism by which two entities can make use of the Session Description Protocol (SDP) to arrive at a common view of a multimedia session between them.  In the model, one participant offers the other a description of the desired session from their perspective, and the other participant answers with the desired session from their perspective.  This offer/answer model is most useful in unicast sessions where information from both participants is needed for the complete view of the session.  The offer/answer model is used by protocols like the Session Initiation Protocol (SIP). [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='3264' />
<format type='TXT' octets='60854' target='http://www.rfc-editor.org/rfc/rfc3264.txt' />
</reference>



<reference anchor='RFC3711'>

<front>
<title>The Secure Real-time Transport Protocol (SRTP)</title>
<author initials='M.' surname='Baugher' fullname='M. Baugher'>
<organization /></author>
<author initials='D.' surname='McGrew' fullname='D. McGrew'>
<organization /></author>
<author initials='M.' surname='Naslund' fullname='M. Naslund'>
<organization /></author>
<author initials='E.' surname='Carrara' fullname='E. Carrara'>
<organization /></author>
<author initials='K.' surname='Norrman' fullname='K. Norrman'>
<organization /></author>
<date year='2004' month='March' />
<abstract>
<t>This document describes the Secure Real-time Transport Protocol (SRTP), a profile of the Real-time Transport Protocol (RTP), which can provide confidentiality, message authentication, and replay protection to the RTP traffic and to the control traffic for RTP, the Real-time Transport Control Protocol (RTCP). [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='3711' />
<format type='TXT' octets='134270' target='http://www.rfc-editor.org/rfc/rfc3711.txt' />
</reference>



<reference anchor='RFC5389'>

<front>
<title>Session Traversal Utilities for NAT (STUN)</title>
<author initials='J.' surname='Rosenberg' fullname='J. Rosenberg'>
<organization /></author>
<author initials='R.' surname='Mahy' fullname='R. Mahy'>
<organization /></author>
<author initials='P.' surname='Matthews' fullname='P. Matthews'>
<organization /></author>
<author initials='D.' surname='Wing' fullname='D. Wing'>
<organization /></author>
<date year='2008' month='October' />
<abstract>
<t>Session Traversal Utilities for NAT (STUN) is a protocol that serves as a tool for other protocols in dealing with Network Address Translator (NAT) traversal. It can be used by an endpoint to determine the IP address and port allocated to it by a NAT. It can also be used to check connectivity between two endpoints, and as a keep-alive protocol to maintain NAT bindings. STUN works with many existing NATs, and does not require any special behavior from them.&lt;/t>&lt;t> STUN is not a NAT traversal solution by itself. Rather, it is a tool to be used in the context of a NAT traversal solution. This is an important change from the previous version of this specification (RFC 3489), which presented STUN as a complete solution.&lt;/t>&lt;t> This document obsoletes RFC 3489. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5389' />
<format type='TXT' octets='125650' target='http://www.rfc-editor.org/rfc/rfc5389.txt' />
</reference>



<reference anchor='RFC5766'>

<front>
<title>Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)</title>
<author initials='R.' surname='Mahy' fullname='R. Mahy'>
<organization /></author>
<author initials='P.' surname='Matthews' fullname='P. Matthews'>
<organization /></author>
<author initials='J.' surname='Rosenberg' fullname='J. Rosenberg'>
<organization /></author>
<date year='2010' month='April' />
<abstract>
<t>If a host is located behind a NAT, then in certain situations it can be impossible for that host to communicate directly with other hosts (peers).  In these situations, it is necessary for the host to use the services of an intermediate node that acts as a communication relay.  This specification defines a protocol, called TURN (Traversal Using Relays around NAT), that allows the host to control the operation of the relay and to exchange packets with its peers using the relay.  TURN differs from some other relay control protocols in that it allows a client to communicate with multiple peers using a single relay address. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5766' />
<format type='TXT' octets='172112' target='http://www.rfc-editor.org/rfc/rfc5766.txt' />
</reference>



<reference anchor='RFC6347'>

<front>
<title>Datagram Transport Layer Security Version 1.2</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization /></author>
<author initials='N.' surname='Modadugu' fullname='N. Modadugu'>
<organization /></author>
<date year='2012' month='January' />
<abstract>
<t>This document specifies version 1.2 of the Datagram Transport Layer Security (DTLS) protocol.  The DTLS protocol provides communications privacy for datagram protocols.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  The DTLS protocol is based on the Transport Layer Security (TLS) protocol and provides equivalent security guarantees.  Datagram semantics of the underlying transport are preserved by the DTLS protocol.  This document updates DTLS 1.0 to work with TLS version 1.2. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='6347' />
<format type='TXT' octets='73546' target='http://www.rfc-editor.org/rfc/rfc6347.txt' />
</reference>



<reference anchor='RFC4960'>

<front>
<title>Stream Control Transmission Protocol</title>
<author initials='R.' surname='Stewart' fullname='R. Stewart'>
<organization /></author>
<date year='2007' month='September' />
<abstract>
<t>This document obsoletes RFC 2960 and RFC 3309. It describes the Stream Control Transmission Protocol (SCTP). SCTP is designed to transport Public Switched Telephone Network (PSTN) signaling messages over IP networks, but is capable of broader applications.&lt;/t>&lt;t> SCTP is a reliable transport protocol operating on top of a connectionless packet network such as IP. It offers the following services to its users:&lt;/t>&lt;t> -- acknowledged error-free non-duplicated transfer of user data,&lt;/t>&lt;t> -- data fragmentation to conform to discovered path MTU size,&lt;/t>&lt;t> -- sequenced delivery of user messages within multiple streams, with an option for order-of-arrival delivery of individual user messages,&lt;/t>&lt;t> -- optional bundling of multiple user messages into a single SCTP packet, and&lt;/t>&lt;t> -- network-level fault tolerance through supporting of multi-homing at either or both ends of an association.&lt;/t>&lt;t> The design of SCTP includes appropriate congestion avoidance behavior and resistance to flooding and masquerade attacks. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4960' />
<format type='TXT' octets='346022' target='http://www.rfc-editor.org/rfc/rfc4960.txt' />
</reference>



<reference anchor='RFC4568'>

<front>
<title>Session Description Protocol (SDP) Security Descriptions for Media Streams</title>
<author initials='F.' surname='Andreasen' fullname='F. Andreasen'>
<organization /></author>
<author initials='M.' surname='Baugher' fullname='M. Baugher'>
<organization /></author>
<author initials='D.' surname='Wing' fullname='D. Wing'>
<organization /></author>
<date year='2006' month='July' />
<abstract>
<t>This document defines a Session Description Protocol (SDP) cryptographic attribute for unicast media streams.  The attribute describes a cryptographic key and other parameters that serve to configure security for a unicast media stream in either a single message or a roundtrip exchange.  The attribute can be used with a variety of SDP media transports, and this document defines how to use it for the Secure Real-time Transport Protocol (SRTP) unicast media streams.  The SDP crypto attribute requires the services of a data security protocol to secure the SDP message. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4568' />
<format type='TXT' octets='107881' target='http://www.rfc-editor.org/rfc/rfc4568.txt' />
</reference>



<reference anchor='RFC2119'>

<front>
<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass. Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>
<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date year='1997' month='March' />
<area>General</area>
<keyword>keyword</keyword>
<abstract>
<t>
   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:

<list>
<t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      RFC 2119.
</t></list></t>
<t>
   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t></abstract></front>

<seriesInfo name='BCP' value='14' />
<seriesInfo name='RFC' value='2119' />
<format type='TXT' octets='4723' target='http://www.rfc-editor.org/rfc/rfc2119.txt' />
<format type='HTML' octets='17970' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
<format type='XML' octets='5777' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
</reference>



<reference anchor='RFC4733'>

<front>
<title>RTP Payload for DTMF Digits, Telephony Tones, and Telephony Signals</title>
<author initials='H.' surname='Schulzrinne' fullname='H. Schulzrinne'>
<organization /></author>
<author initials='T.' surname='Taylor' fullname='T. Taylor'>
<organization /></author>
<date year='2006' month='December' />
<abstract>
<t>This memo describes how to carry dual-tone multifrequency (DTMF) signalling, other tone signals, and telephony events in RTP packets. It obsoletes RFC 2833.&lt;/t>&lt;t> This memo captures and expands upon the basic framework defined in RFC 2833, but retains only the most basic event codes. It sets up an IANA registry to which other event code assignments may be added. Companion documents add event codes to this registry relating to modem, fax, text telephony, and channel-associated signalling events. The remainder of the event codes defined in RFC 2833 are conditionally reserved in case other documents revive their use.&lt;/t>&lt;t> This document provides a number of clarifications to the original document. However, it specifically differs from RFC 2833 by removing the requirement that all compliant implementations support the DTMF events. Instead, compliant implementations taking part in out-of-band negotiations of media stream content indicate what events they support. This memo adds three new procedures to the RFC 2833 framework: subdivision of long events into segments, reporting of multiple events in a single packet, and the concept and reporting of state events. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4733' />
<format type='TXT' octets='115614' target='http://www.rfc-editor.org/rfc/rfc4733.txt' />
</reference>




    </references>




  </back>
</rfc>

