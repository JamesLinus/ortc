<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<rfc ipr="trust200902" docName="draft-raymond-rtcweb-webrtc-js-obj-rtc-00" category="std">

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

  <front>
    <title>WebRTC JavaScript Object RTC</title>

    <author initials="R." surname="Raymond" fullname="Robin Raymond">
      <organization>Hookflash</organization>
      <address>
        <postal>
          <street>436, 3553 31 St. NW</street>
          <city>Calgary</city>
          <region>Alberta</region>
          <code>T2L 2K7</code>
          
        </postal>
        
        
        <email>robin@hookflash.com</email>
        
      </address>
    </author>
    <author initials="C." surname="Dorn" fullname="Christoph Dorn">
      <organization>Independent</organization>
      <address>
        <postal>
          <street>1999 Highway 97 South</street>
          <city>West Kelowna</city>
          <region>BC</region>
          <code>V1Z 1B2</code>
          <country>Canada</country>
        </postal>
        
        
        <email>christoph@christophdorn.com</email>
        
      </address>
    </author>
    <author initials="E." surname="Lagerway" fullname="Erik Lagerway">
      <organization>Hookflash</organization>
      <address>
        <postal>
          <street>436, 3553 31 St. NW</street>
          <city>Calgary</city>
          <region>Alberta</region>
          <code>T2L 2K7</code>
          <country>Canada</country>
        </postal>
        
        
        <email>erik@hookflash.com</email>
        
      </address>
    </author>
    <author initials="I." surname="Baz Castillo" fullname="Inaki Baz Castillo">
      <organization>Versatica</organization>
      <address>
        <postal>
          <street>Barakaldo</street>
          <city>Basque Country</city>
          
          
          <country>Spain</country>
        </postal>
        
        
        <email>ibc@aliax.net</email>
        
      </address>
    </author>
    <author initials="R." surname="Shpount" fullname="Roman Shpount">
      <organization>TurboBridge</organization>
      <address>
        <postal>
          <street>4905 Del Ray Ave Suite 300</street>
          <city>Bethesda</city>
          <region>MD</region>
          <code>20814</code>
          <country>USA</country>
        </postal>
        
        
        <email>rshpount@turbobridge.com</email>
        
      </address>
    </author>

    <date year="2013" month="July" day="05"/>

    <area>General</area>
    <workgroup>Network Working Group</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This draft outlines an alternative approach to the current JSEP <xref target="I-D.ietf-rtcweb-jsep"/> / WebRTC 1.0 draft <xref target="WebRTC10"/> and removes the dependency requirements on the SDP <xref target="RFC4566"/> and Offer / Answer <xref target="RFC3264"/> state machine or reliance upon an all-encompassing master media description format that describes the entire RTP transport and media states. This draft describes how the WebRTC Use-cases and Requirements <xref target="I-D.ietf-rtcweb-use-cases-and-requirements"/> and Media Transport and Use of RTP <xref target="I-D.ietf-rtcweb-rtp-usage"/> are satisfied by such an alternative approach (where the use cases are applicable). The rationale for needing an alternative approach is described in the WebRTC JS Object API Rationale draft <xref target="I-D.raymond-rtcweb-webrtc-js-obj-api-rationale"/>.</t>

<t>This draft outlines how WebRTC signaling negotiation information required to perform RTC on-the-wire can be organized into object-like constructs to minimize cross-dependencies between negotiated information, round-trip signaling, and co-dependency in negotiated state transitions. This results in greater flexibility for signaling protocols other than those based on SDP/SIP <xref target="RFC3261"/> (but not to exclude SDP/SIP). The flexibility to implement other signaling options is achieved by not imposing an all-encompassing session description format and the offer / answer state machine, such as described in JSEP <xref target="I-D.ietf-rtcweb-jsep"/>. Finally, this draft outlines how a reference shim can be implemented on top of this proposal for those who would prefer a JSEP / SDP model for their signaling.</t>



    </abstract>


  </front>

  <middle>


<section anchor="problems" title="Introduction">

<t>This draft describes how an object-like construct model can be used to control the setup, manage, negotiate and control Real-Time Communications (RTC) from the Browser and how these concepts are transform into on-the-wire constructs, as an alternative to JSEP’s approach. The provided example-only API is presented merely as input guidelines for the W3C to ensure their API constructs allow for the correct interpretation to on-the-wire RTC control and signaling constructs needed as defined in the various use case drafts related to RTCWEB. The draft outlines an alternative JavaScript RTC control model that does not require a complex all-encompassing session description format, like SDP, or related offer / answer state machine to describe the entire transport and media states. This allows for greater flexibility with other non-SDP offer / answer based signaling protocols. The actual final API is entirely within the scope of the W3C (as it should be).</t>

<section anchor="general-design-of-webrtc-js-object-model" title="General Design of WebRTC JS Object Model">

<t>The design of this object model is to split the information required to setup a RTC session into logical object components, information and relationships where they are needed rather than on requiring a single all-encompassing RTC session description format and its related offer / answer state machine. Further, the coordination of the information that must be exchanged in signaling is left to the decision of the JavaScript developer to allow for a variety of signaling approaches, rather than imposing a single model with offer / answer.</t>

<t>By splitting the RTC concepts into logical objects components, the choice of approaches for the signaling path becomes even more flexible and the information needed for each component becomes minimized and much easier to standardize. The local object components can be replaced in the future should the information required for each component change, or if a new type of object is needed for different types of media or RTP engine features.</t>

<t>For example, some of the complex information required to exchange for RTP is the media stream track to SSRC associations. This information must be signaled to correctly reassemble RTP media into proper streams on the remote side. However, the only reason this mapping needs to be in signaling is because of the limitations of current RTC engines / protocols, which do not understand the concept of streams, or other features like FEC. Should a better RTP engine / protocol be defined in the future, it will be possible to replace the RTP component with “next gen RTP”. Such an object that does understand things like streams and FEC and the component and information would not necessarily need mappings and might become a simplified alternative to the RTP model.</t>

<t>This WebRTC JavaScript object model still allows all the key information required for various signaling models, and the information can be exchanged easily as the information is modular, limited, and accessible. For the average JavaScript developer, the objects model is simplistic but still allows those developers who require greater control and flexible access to the constructs they require from an RTC engine inside the browser without needing to perform extensive parsing, mangling and regeneration of a master know-everything session format (such as SDP).</t>

<t>This model further reduces the requirements imposed on traditional / legacy devices by not requiring these devices to understand a vastly more complex session description format or by requiring an intermediary to interpret this complex master session description and state machine into something more palatable for the device.</t>

<t>The main design goals are to:</t>

<t><list style='numbers'>
  <t>allow multiple alternative on-the-wire signaling alternatives without imposing a know-everything media description format and related offer / answer state machine.</t>
  <t>mandate only the use of the RTC on-the-wire protocols needed to satisfy the use cases and requirements, as described in <xref target="I-D.ietf-rtcweb-use-cases-and-requirements"/> and related documents.</t>
  <t>allow granular information to be exchanged based upon logical objects in a method and timing decided best by the implementor.</t>
  <t>allow for control of the RTC engine with maximum flexibility, while still adhering to the unique security requirements of browsers.</t>
  <t>minimize the requirements needed for basic and simple JavaScript use cases.</t>
  <t>resolve the PlanA <xref target="I-D.roach-rtcweb-plan-a"/>, PlanB <xref target="I-D.uberti-rtcweb-plan"/> and NoPlan <xref target="I-D.ivov-rtcweb-noplan"/> conflicts arising from handling multiple media sources.</t>
  <t>borrow liberally from the concepts already proposed in other places where possible to merge the various concepts.</t>
  <t>resolve or limit as many of the concerns presented in the accompanying rationale document <xref target="I-D.raymond-rtcweb-webrtc-js-obj-api-rationale"/> as possible.</t>
</list></t>

</section>
<section anchor="other-approaches-considered" title="Other Approaches Considered">

<t>By not imposing a master transport and media description format, a JavaScript developer will not be exposed to a complex unfamiliar session description format with little high level control over what’s happening at protocol layers. The current approach requires developers to perform extensive parsing, interpret or transform this master session description when more control is required. Decoupling the master know-everything session format and the state machine required to exchange it into logical well-defined components with non-specified requirements on how the information must be exchanged allows for greater understanding of the information and flexibility in signaling. The net result should be less brittle implementations that are not dependent upon an ever evolving, adaptable and expanding master know-everything format.</t>

<t>Contrary to the assertions stated in JSEP <xref target="I-D.ietf-rtcweb-jsep"/> “1.2 Other Approaches Considered”, the WebRTC JavaScript object model proposed does not result in overly complex JavaScript code to perform simple and basic WebRTC implementations. The simple scenarios for RTC control from JavaScript are no more complex than the simple JSEP examples and do not require dependency on additional libraries to create a reasonable reference implementation. Whereas the complexity required to implement other more advanced scenarios that do not follow the specific offer / answer state machine model is greatly reduced relative to JSEP’s requirements. The manual manipulation and transformation of a complex session description format generated by the browser is all but eliminated. Only those who must implement a particular type of session format will be required to parse and generate that format without imposing that format upon others.</t>

<t>The WebRTC JS Object Model does not implement or add any features other than those already existing in WebRTC 1.0, but because of it’s granular object based approach, it allows for a variety of alternative signaling scenarios that are difficult to achieve with the current WebRTC API <xref target="WebRTC10"/>. In fact, the requirements for a browser are eased by virtue of not having to handle an all-encompassing media description format with an offer / state machine. Both models need to perform all the same logic routines internally, including all the RTP data muxing rules, but the WebRTC object model removes many of the unneeded restrictions and burdens placed on a JavaScript developer on how a signaling protocol must work, and decouples the data needed to transform the object information into alternative formats.</t>

</section>
</section>
<section anchor="terminology" title="Terminology">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 <xref target="RFC2119"/>.</t>

</section>
<section anchor="object-data-and-control-model" title="Object, Data and Control Model">

<section anchor="objsocket" title="MediaSocket, DataSocket, MediaDataMuxSocket">

<t>Each one of these types of transports is capable of carrying the appropriate type of streams implied by their name. The MediaSocket and MediaDataMuxSocket can carry media streams whereas the DataSocket and MediaDataMuxSocket can be used to carry data streams.</t>

<t>Under most usual conditions, a developer would want a “multipurpose” MediaDataMuxSocket, which is why a connection <xref target="objconnection"/> object by default creates this type of socket. However, there are rarer conditions where a developer may wish to split out the ports rather than mux them, thus they can create individualized sockets only when needed and provide them to the connection object. For example, a connected device may require the data and media sockets separate because it cannot support demuxing. Or the developer desires to split the audio and video to prevent the audio port buffering from being overflowed from video buffering.</t>

<t>The developer must be able to provide each of these sockets a list of stun and turn servers. This allows the socket to discover other network-reflective network mappings and open up relay network sockets to allow the socket to be “remoted” when direct connections to the socket are not possible.</t>

<t>Should the socket supports DTLS <xref target="RFC6347"/> (or DTLS/SCTP <xref target="RFC4960"/>), the developer’s JavaScript must be able to be provided an alternative private / public certificate pair, rather than utilizing the browser’s pre-generated certificate(s) (for further discussion on this issue see the Security Section (<xref target="jscertificates"/>)). The media sockets may be provided a restrictive list of media “kinds” they are allowed to transport, for example “audio”, and / or “video”. This allows the media socket to restrict the kinds of media stream tracks allowed to be transported on a particular socket. For example, a developer might wish audio to send over one socket and video to be sent over a different socket.</t>

<t>The JavaScript developer must be able to control the mapping of what kind of streams or tracks go over which socket(s).</t>

</section>
<section anchor="objconnection" title="Connection">

<t>A connection is an object that represents the logical connection between two Internet peers. Each peer constructs a connection object that gathers candidates (i.e. possible methods to connect over the Internet) and allows an external signaling mechanism to exchange these candidates between the peers. The peers test the candidates for connectivity and establish a connection once a candidate pairing discovers connectivity (see <xref target="I-D.rescorla-mmusic-ice-trickle"/>).</t>

<t>Once a connection is established on all sockets, an event must be fired to the developer’s JavaScript / application to indicate connectivity. The connection remains established until disconnected by programmatic intent or by timeout failure, upon which time a disconnect event must be fired to indicate the disconnection state with the appropriate listed reason. Should the connection fail to connect, a disconnection event must fire with the appropriate listed reason.</t>

<t>Once a connection is established between peers, a connection can be used to transmit media or data utilizing the associated media or data sockets as appropriate. Appropriate constraints (<xref target="objconstraints"/>) for each connection must be exchanged before media streams may flow between peers.</t>

<t>A connection must provide by default a multipurpose socket (<xref target="objsocket"/>) (e.g. MediaDataMuxSocket) capable of carrying a variety of stream types if no socket is specified.</t>

<section anchor="relationship-to-socket" title="Relationship to Socket">

<t>Each connection {#objconnection} object must have one or more sockets ({#objsocket}), and multiple connections can share the same socket objects. By default, a connection creates a multipurpose socket (e.g. MediaDataMuxSocket) if none is specified. In a forked condition (<xref target="interactionforking"/>), the connections will share the same socket objects. A socket represents a single logical connection binding on a network interface, thus a unique set of negotiations occurs for each ICE (<xref target="objice"/>) session on each socket despite the negotiation being performed on the same connection (which is demuxed by way of the “socket id” on the candidate description (<xref target="objcandidatedescription"/>)).</t>

</section>
<section anchor="objconnectiondescription" title="Connection Description">

<t>While a connection might have a variety of other properties, every connection object has a description structure that must have the following properties:</t>

<t><list style='symbols'>
  <t>cname - an optional cname override to use for all RTP streams within the connection (if none is provided a default will be selected).</t>
  <t>contextId - a cryptographic random identifier for the connection auto-generated by the browser, which has a dual purpose of serving as the ICE userFrag.</t>
  <t>secret - a cryptographic random string that can be used within the context of the connection as needed, which has a dual purpose of serving as the ICE password. If the secret is used in any other signaling keying, it must be appropriately salted using standard cryptographic salting principles.</t>
  <t>fingerprints - an ordered list of all the hash fingerprints of any public keys used in the sockets (see <xref target="fingerprintresponsibility"/>).</t>
</list></t>

<t>A context identifier is used not only for the ICE username, it must be a common id that remains stable across forked connections. This allows the developer to correlate the forked connections as appropriate by a JavaScript developer.</t>

<t>The information contained in a connection’s description must be exchanged with a remote peer’s connection object before any candidate connectivity checks may be performed by the browser. The exact method and timing of the exchange must be left to the discretion of the JavaScript developer.</t>

<section anchor="connection-description-negotiation" title="Connection Description Negotiation">

<t>The local peer has a connection description. The remote peer has a connection description. Each peer must exchange the information in the connection description with the other through signaling. The contextId becomes the useFrag, and the secret becomes the password for ICE signaling (see <xref target="RFC5245"/>). The CNAME is used as part of the RTCP reporting (see <xref target="RFC3550"/>) so that each peer can establish stream to peer correlation.</t>

<t>Each connection has an array of fingerprints for each socket added to the connection that supports DTLS <xref target="RFC6347"/>. These fingerprints must be signaled in order to preserve the fingerprint to DTLS mapping of each socket. The connection object is responsible for ensuring any remotely connected peer’s fingerprint during DTLS exchange matches the fingerprint provided in the connection description of the remote peer. If the fingerprint does not match, the connection must be closed.</t>

</section>
</section>
<section anchor="objice" title="ICE">

<t>ICE <xref target="RFC5245"/> is a standard used for discovering peer connectivity. A browser must support both ICE, and the ICE modification extension trickle ICE <xref target="I-D.rescorla-mmusic-ice-trickle"/> connectivity discovery mechanisms. The browser may support additional peer connectivity methods other than ICE.</t>

<t>When the browser detects a candidate is available, the candidate must be sent as an event to the developer’s JavaScript. If all possible candidates have been discovered, the browser must send a discovery completion event to the developer’s JavaScript.</t>

<t>Should the browser fire non-ICE candidate events to the developer’s JavaScript, the developer’s JavaScript should be able to deliver the candidate information to the remote peer ‘as is’ if the developer’s signaling protocol allows for alternative non-ICE candidates. The browser must define a clear method to distinguish standard ICE discovered candidates from non-ICE extension candidates for signaling protocols unable to handle non-ICE connection candidates.</t>

<section anchor="ice-candidate-trickling" title="ICE Candidate Trickling">

<t>The browser must support trickle ICE <xref target="I-D.rescorla-mmusic-ice-trickle"/> discovery mechanism. This mechanism allows the browser to provide candidate information as they are discovered, thus allowing the developer’s JavaScript to exchange this information to a remote peer via signaling. As candidates are exchanged, the browser must perform connectivity checks as defined by trickle-ICE even while other candidates are still being discovered and exchanged via signaling (to allow for faster connection times).</t>

<t>Before any connectivity checks may be performed by a browser, a connection’s description information (<xref target="objconnectiondescription"/>) must be received from a remote peer’s connection.</t>

</section>
<section anchor="objcandidatedescription" title="ICE Candidate Description">

<t>Each ICE candidate has description information containing the following:</t>

<t><list style='symbols'>
  <t>socket id - the socket identifier where the candidate was discovered, matching the identifier specified in the MediaSocket, DataSocekt or MediaDataMuxSocket (<xref target="objsocket"/>) provided to the connection (<xref target="objconnection"/>) object</t>
  <t>foundation (as as defined in RFC5245 <xref target="RFC5245"/>)</t>
  <t>component id (as as defined in RFC5245)</t>
  <t>transport (as as defined in RFC5245)</t>
  <t>priority (as as defined in RFC5245)</t>
  <t>connection address (as as defined in RFC5245)</t>
  <t>connection port (as as defined in RFC5245)</t>
  <t>type (defined as “srflx”, “prflx”, or “relay” whose meaning is derived from RFC5245)</t>
  <t>related address (as as defined in RFC5245)</t>
  <t>related port (as as defined in RFC5245)</t>
</list></t>

<t>Other non-ICE candidate types may contain other types of description information. The browser should implement only well described candidate types, or namespace the candidate type to not become confused with potential standardized candidate types. By using standardized descriptions, the browser will help facilitate translation to alternative signaling protocols. The developer’s JavaScript should be able to transport the candidate description information ‘as is’ even if the description information is not understood so long as the developer’s signaling protocol allows for alternative candidate types.</t>

<t>The candidate descriptions may be relayed to the remote peer independent of other description information or bundled together with other descriptions as determined by the needs of the JavaScript developer. The browser must not impose restrictions on external signaling protocols related to the exchange of candidates, or require the bundling of other types of descriptions, such as constraint descriptions (<xref target="objconstraints"/>) or stream descriptions (<xref target="objstreamdescriptions"/>).</t>

</section>
</section>
<section anchor="objconstraints" title="Constraints">

<t>Constraints consist of a list of media codecs and cryptographic encryption algorithms allowed to be used as part of the transmission of media. Constraints can consist of additional rules or limitations, for example; video size or bandwidth limitations. A developer’s JavaScript must be able to obtain the types of constraints supported by the browser (<xref target="objfeaturediscovery"/>), and the default set of codecs and algorithms available.</t>

<t>Send constraints indicate media constraints that apply to media flowing from the local to the remote peer. Receive constraints apply to the media flowing to the local peer from a remote peer. The constraints may be identical in both directions, or the constraints may be a negotiated subset, or the constraints may be unique per direction (i.e. send versus receive). A developer’s JavaScript must must be able to set the constraints on either direction, at will, and obtain the possible constraints for a connection.</t>

<section anchor="constraints-negotiation" title="Constraints Negotiation">

<t>The media constraints must be exchanged via some external signaling method by the developer’s JavaScript. The local send constraints must be (at minimal) a subset of the received constraints of the remote peer, and the received constraints must be (at minimal) a subset of the send constraints of the remote peer. Should the browser be unable to fulfill the provided constraints for any reason (for example, none of the codecs were compatible), an error most be propagated to the developer’s JavaScript, which should handle this condition rather than silently fail. The RTCWEB Working Group must define a mandatory common set of codecs and encryption algorithms to help alleviate the possibility of codec and algorithm failure conditions.</t>

<t>The browser must not dictate the timing or format of how constraints are exchanged, nor the rules of how each peer must provide the information, nor how the information is signaled.</t>

<t>The browser should only support codecs and algorithms that are well documented standards. The browser must namespace non-standard codecs and encryption algorithms using a method that will not cause confusion with codecs and algorithms that might become standardized in the future. The properties for each standardized codec and encryption algorithm must be defined clearly. By defining each codec and encryption algorithms’ properties, alternative signaling protocols may translate the standardized codecs and algorithms into their respective signaling protocols. If a browser does not have specific knowledge of a codec, or an encryption algorithm supplied by a developer’s JavaScript, it must ignore the non-understood codecs, and / or algorithms. A JavaScript developer may encode and signal non-standard codecs and algorithms so long as none of the browser provided properties (for the codecs and encryption algorithms) are lost during signaling exchange.</t>

<t>Other non-codec and non-encryption constraints may be set for a connection. For example; a developer may wish to set the maximum video dimensions for a connection. The browser should only implement standardized constraints and namespace non-standard constraints to ensure that no conflict arises should a constraint become standardized.</t>

<t>These “other” types of constraints are split into two categories: required (i.e. mandatory) or optional. The browser should not generate “other” mandatory constraints by default but must allow the developer’s JavaScript to dictate mandatory constraints. If the mandatory constraint cannot be fulfilled or is not understood by the browser, the browser must propagate an error to the developer’s JavaScript. A developer’s JavaScript should properly handle a failure condition and must act appropriately (i.e. fail accordingly) when receiving a mandatory constraint that it is unable to fulfill, correctly signal (if applicable), or correctly understand. Mandatory constraints should be used sparingly.</t>

<t>Optional “other” constraints must be considered optional and any constraint property of this nature may be ignored. However, if the browser or the developer’s JavaScript understands the constraint property, the property must be respected.</t>

<t>A developer’s JavaScript may choose what constraints to signal to a remote peer, or not. The developer must only set constraints that are either understood, or were generated by the browser and signaled ‘as is’ to the remote party. A developer should attempt to signal all constraints generated by the browser to the remote party, but may choose to filter only the understood constraints.</t>

<t>The browser should only implement standardized constraints and must namespace non-standardized constraints appropriately to avoid conflict with constraints that might be standardized in the future.</t>

</section>
</section>
<section anchor="objstreamdescriptions" title="Media Stream (and Media Stream Track) Descriptions">

<t>RTP is the current standard for performing real-time media transmission. While RTP is effective at media transmission, the RTP transport lacks sufficient details to convert a WebRTC stream object into an RTP transmission and back into an WebRTC stream on the remote peer (where stream objects consist potentially of multiple audio, video (or other) media tracks).</t>

<t>Further, the exact mapping of which sockets and codecs are used is unspecified. RTP does have a SSRC (Synchronization source identifier) for every media stream sent over it which can be used to coordinate the RTP streams. A signaling layer must describe this coordination to be able to synchronize the streams from one peer to another.</t>

<t>Other features, like FEC (Forward Error Correction), are not described in WebRTC stream objects because they are a feature of a transport. Each stream could allow a media track to be sent redundantly on the wire so if part of the stream was damaged during the transmission it could be reconstructed from the redundant stream. Another case is simulcasting where the same media track is encoded multiple ways, for example video layering effects or various encoding sizes (thumbnails vs full streams).</t>

<t>RTP lacks sufficient information to be able to describe FEC or simulcasting as part of its transmission, thus a higher layer must signal this information to a remote peer if these features are to be supported.</t>

<t>The browser must provide a method to create a stream description for the features it supports, to allow for stream and track synchronization (and correlation), and other transport features like FEC or simulcast. The exact mapping structures for the stream must be clearly defined in exacting detail, describing the expected behaviors and use cases a browser must support.</t>

<t>For each track in a stream the browser must supply the following information:</t>

<t><list style='symbols'>
  <t>track-id - the identifier of the track (i.e. from MediaStreamTrack.id <xref target="MediaCapture"/>)</t>
  <t>socket id - the identifier correlating to the media socket (<xref target="objsocket"/>)</t>
  <t>ssrc - the SSRC of the track as defined by RFC3550 <xref target="RFC3550"/></t>
  <t>kind - the kind of media being transported (meaning derived from MediaStreamTrack <xref target="MediaCapture"/>)</t>
  <t>constraints - (optional, the default send / receive connection (<xref target="objconnection"/>) constraints apply if not specified)</t>
</list></t>

<t>If FEC is supported by the browser and the developer’s JavaScript has enabled the feature, the browser must supply the following additional information on FEC tracks:</t>

<t><list style='symbols'>
  <t>the redundancy SSRC - the SSRC that is redundant to the current track</t>
</list></t>

<t>(NOTE: FEC is a complex subject with alternative methods to perform the same levels of redundancy. This draft takes no position on the best techniques and practices and only suggests one method for describing FEC within the steam description. As other description formats are able to support various FEC scenarios, the descriptive information for various FEC scenarios could easily be added into this draft depending on what the IETF/W3C wish to support by default.)</t>

<t>The browser must support a developer’s JavaScript specifying constraints per track on both the send and receive ends of the track. As each SSRC can be demuxed from other SSRCs at the RTP layer, the constraints can be applied per track.</t>

<t>While these stream (and track) descriptions are intended to be sent to remote peers, the browser must not mandate the timing, format, or the signaling of these stream descriptions.</t>

<section anchor="objfuturestreamdescriptions" title="Future Media Stream Descriptions">

<t>The complexity in describing streams and tracks is mostly born because RTP lacks sufficient definition to reassemble RTP media tracks into streams on a remote peer. In the future, a new “next generation” RTP may become standard. In such a case, the “next generation” RTP layer may support the concept of tracks, streams, or things like FEC, and simulcasting.</t>

<t>If a “next generation” RTP transport becomes defined, a stream description might be different or not required at all, or perhaps with other properties yet to be defined. Each new supported transport type must define exactly the stream definition expected to be produced by the browser, if any at all.</t>

</section>
</section>
<section anchor="sending-media-streams-over-rtp" title="Sending Media Streams (over RTP)">

<t>The browser must be able to support sending streams via a connection <xref target="objconnection"/> over the socket(s) <xref target="objsocket"/>. The developer’s JavaScript must be able to indicate to the browser the stream and track mappings (in the form of a stream description) if the transport requires this information (assuming it is required, see <xref target="objfuturestreamdescriptions"/>).</t>

<t>The browser must respect the media stream track mapping to the socket <xref target="objsocket"/>, SSRC, and optional constraints. The “kind” property for sending is merely information but is not explicitly required, but if set, must match the media stream track’s “kind”. The developer’s JavaScript must be able to specify that individual media stream track may be omitted from sending, while other media stream tracks are sent.</t>

<t>The developer’s JavaScript must be able to control the exact timing when a stream starts to send and when a stream stops sending. At any time, the developer’s JavaScript must be able to change the track mapping and constraints without the browser imposing any signaling requirements to a remote peer, thus allowing for various alternative signaling scenarios.</t>

<t>The browser must only utilize the codecs within the constraints provided for sending, and alternate codecs at will. A browser should decide which codec is best suited for the network conditions amongst all the codecs within the send constraints. If a developer’s JavaScript wishes to limit to a particular codec, the send constraints should only contain the codec desired.</t>

<t>If FEC is supported, the browser must coordinate the sending of the FEC RTP redundancy tracks.</t>

</section>
<section anchor="receiving-streams-over-rtp" title="Receiving Streams (over RTP)">

<t>The browser must be able to support receiving streams via a connection <xref target="objconnection"/> over the socket(s) <xref target="objsocket"/>. The developer’s JavaScript must be able to specify the streams expectations for any streams about to be received (or currently being received).</t>

<t>The developer’s JavaScript is not required to signal the stream mapping should the developer not care about stream and stream track reassembly, or if the developer will manually assemble the streams tracks into streams based on their own logic. If media tracks arrive without any stream definition, the browser must render the RTP streams as media stream tracks unattached to a particular stream. Should the developer’s JavaScript eventually specify a stream definition, the browser must assemble the individual tracks into streams according to the stream definitions. The developer’s JavaScript must be able to assemble individual stream tracks into streams manually should the developer not wish to provide a stream definition.</t>

<t>The browser must be able to render the same media stream track as part of multiple media stream objects, to allow a stream definition to contain the same track in multiple streams.</t>

<t>Each media stream track is demuxed first by the socket (<xref target="objsocket"/>), then by the SSRC, then by “kind” based upon the codec “kind” of the payload. While technically possible to demux upon the same “kind”, the browser must only support demuxing the same media “kind” with the same SSRC if the payload id used only matches one set of constraints for a particular track on the receiving stream. A developer’s JavaScript should not mux the same “kind” of media on the same SSRC. A developer’s JavaScript should not mux different “kinds” of media on the same SSRC.</t>

<t>A developer’s JavaScript must provide a stream definition to receive any streams that utilize the FEC feature when transmitting over RTP.</t>

<section anchor="loosedescriptions" title="Loosely Matching Media Stream Descriptions">

<t>The browser must support loose definitions for streams where a signaling was not used to send stream descriptions between peers. This allows the browser to support simpler signaling protocols which are either incapable or unwilling to signal stream descriptions.</t>

<t>The browser should be able to receive a stream without specifying any details. In this case, the browser will attach all incoming media stream tracks of different media kinds into the stream specified. In such a case, the browser will apply loose rules to automatically determine which track belongs to which stream, factoring in such things as the sockets, kinds of media on each socket, and the constraints provided (and perhaps timing). This allows for very simple signaling use cases where the developer doesn’t need to signal stream details needlessly for the most common use cases. Alternatively, the developer’s JavaScript should be able to specify partial or complete details such as socket id, to indicate a particular socket, or a “kind” to filter on particular kinds of media, or even on an SSRC that was generated and presumed based on an algorithm of the developer’s choosing. This allows the developer’s JavaScript complete control over the level of precision in the stream matching they can expect.</t>

<t>When filters are used for a stream description to define specific track definitions, the browser should match upon the most specific rule if items like the SSRC are specified in the rules. As the browser API defined by the W3C, the W3C must define specific rules to follow when receiving streams that make most sense for their anticipated use cases.</t>

<t>The intention of allowing for loose rules is to allow for a larger variety of signaling scenarios where simple “loose” rules could be used to match the media stream tracks rather than always mandating signaling be exchanged. Loose rules may work well for many and most common use cases, but still allows the developer to signal specifics when they do not suffice.</t>

</section>
</section>
<section anchor="objdatastreamdescription" title="Data Stream Description">

<t>A data stream is an object that is a specialized type of stream (see <xref target="datastream"/>), just as a media stream is an object for media related information. The data stream description contains the following properties:</t>

<t><list style='symbols'>
  <t>stream id - the identifier for the data stream (from MediaStream.id <xref target="MediaCapture"/>)</t>
  <t>socket id - the socket to carry the data stream (<xref target="objsocket"/>)</t>
</list></t>

<t>The browser must not define or specify how or when the signaling for the data stream description is sent.</t>

</section>
<section anchor="sending-data-streams-over-datasocekt" title="Sending Data Streams (over DataSocekt)">

<t>The browser must be able to send a data stream over the connection as long as a data stream compatible socket has been added, otherwise an error must be propagated to the developer’s JavaScript. For the simple case, the developer’s JavaScript should be able to send the stream without any additional information being specified to allow for simple signaling scenarios where the data stream mapping is unimportant.</t>

</section>
<section anchor="receiving-data-streams-over-datasocket" title="Receiving Data Streams (over DataSocket)">

<t>In the receive direction, the browser must be able to open a data stream based upon the data stream description information from the remote peer. The browser should support a method to fetch the next available data stream without needing any specifier to handle simple signaling scenarios where specific stream mappings are unimportant.</t>

</section>
</section>
<section anchor="objfeaturediscovery" title="RTC Feature Discovery">

<t>The browser must have a method to allow a developer’s JavaScript to determine what RTP features are available from the browser’s RTC engine without performing browser and browser version detection. While some features can be probed by way of checking if an object exists to support the feature, other features cannot. For example; the developer’s JavaScript should be able to probe the browser to answer “Does the RTC engine support FEC?”</t>

<t>At minimum, each feature only needs to be a well defined standardized string that determines the exact expectations, feature sets and behaviors that are supported by the browser’s RTC engine. Should the browsers define custom extension features, the browser must namespace each feature in such a way to avoid non-standard features from conflicting with a potential future standardized definition.</t>

<t>RTC features can be vast and complex. Having a feature discovery is especially important to allow for a variety of implementations without setting the requirements bar too high on browser implementations. Developers also need a method to ensure (through JavaScript) they can detect which options are available to remain compatible. Performing unreliable browser probing techniques is not sufficient. Many RTC features are hidden behind complex rules in the engine and cannot be probed easily, for example, FEC.</t>

</section>
<section anchor="dtmf" title="Example: DTMFMediaStreamTrack Specialization">

<t>One of the use case requirements in Web Real-Time Communication Use-cases and Requirements is DTMF navigation of IVR systems <xref target="I-D.ietf-rtcweb-use-cases-and-requirements"/>. Typically DTMF is performed by transmitting RTP data as described in RFC 4733 <xref target="RFC4733"/>.</t>

<t>One possible method to implement a DTMF data stream is by specialization of the media stream track. The stream description (<xref target="objstreamdescriptions"/>) does allow for mapping a track to an RTP mapping and DTMF does not require any special mapping, except ensuring the DTMF track shares the same SSRC as an audio track. The browser should create reasonable rules to auto-pair a DTMF stream track to an audio track for a stream description.</t>

<t>The browser engine must interpret signals given from the DTMF stream to override the audio stream to send DTMF packets as described in RFC 4733. The browser must define a special codec for DTMF with a kind defined as “dtmf”.</t>

<t>Should the decision to interpret incoming DTMF tones be mandated by the RTCWEB WG then the browser should interpret received DTMF tones received as per RFC 4733 and fire events that a developer’s JavaScript can intercept. For a use case example, as browser engines are being embedded in other technologies, such as Node.js, having the browser be capable of interpreting DTMF signals may allow for JavaScript server based IVR style-system when bundled with a relevant signal protocol.</t>

</section>
<section anchor="datastream" title="Example: DataStream Specialization">

<t>A data stream object can be a specialized type of stream, just as media stream is used for sending media data. Data streams allow data to be transmitted over a data compatible socket (<xref target="objsocket"/>), such as DTLS/SCTP <xref target="RFC6347"/>/<xref target="RFC4960"/>. A data stream is a bi-direction stream allowing for each peer to send and receive data over the same data stream.</t>

<t>To open a data stream, one peer must initiate the stream through a browser supplied send method, and another peer must be able to receive an event in JavaScript about the new incoming data stream. The developer’s JavaScript must be able to start receive data stream events for any sent data. Both peers via JavaScript must be able to send data to the other and receive data stream events.</t>

</section>
</section>
<section anchor="signaling-models" title="Signaling Models">

<section anchor="sdp-with-offer-answer" title="SDP with Offer / Answer">

<t>While it could be said that the current WebRTC 1.0 API <xref target="WebRTC10"/> is best suited for SDP / SIP, that might not be the case. Many SIP networks have a large investment in their SIP infrastructures and technology, and updating all of their technology is not simple. If what the browser produces for SDP is not 100% compatible, they must either convert to SDPs from the browser via JavaScript to SDPs that are compatible, or introduce other gateways that do the conversion. By removing SDP from the browser, this allows the SIP vendors to generate SDP specifically tailored to their SIP network, and more easily control the exact conditions in the browser they need to be compatible.</t>

<t>In other words, one could argue that SDP / SIP developers wouldn’t need to do extra work to be compatible with the browsers, but for many, that simply might not be true. Having SDP generated in the browser allows a SIP network provider less control over what SDP is produced than having JavaScript produce the SDP as a dynamically updated downloaded module where all browsers produce the identical SDP. To explore this reasoning further please see the related rationale draft <xref target="I-D.raymond-rtcweb-webrtc-js-obj-api-rationale"/>.</t>

<t>This section will outline how JavaScript can generate an SDP from basic descriptions, just as an SDP parser can reconstruct the information each object’s description requires. Yet these SDPs that are produced are custom tailored with exact specifications yielding greater compatibility than relying upon each browser to produce identical SDPs.</t>

<section anchor="constructing-an-offer" title="Constructing an Offer">

<t>The first step required is creating a connection object. The connection object can optionally be constructed with various socket configurations for transport, such as separating audio and video RTP sockets, or muxing the data on the same socket as RTP. The developer can obtain the send constraints and populate the “m=” line(s) for the media desired, as well as all the codec and cryptography information. The ice userFrag and password information is available from the connection object. If the SDP must generate SSRC mappings, the “getDescription” method can be used to obtain the mapping information in order to generate the various SDP SSRC entries accordingly. Finally, the ICE candidates will be notified using an “onconnectioncandidate” event and the offer can either be generated before all candidates arrive, or after once all candidates are ready.</t>

<t>The peer can be put into an “offer” state.</t>

</section>
<section anchor="parsing-an-offer" title="Parsing an Offer">

<t>When a remote peer receives an offer, the peer must construct an answer, but it must parse the offer before this. The first step is to parse out the SDP information as per the expectations of how it was generated. Since the offer was constructed with JavaScript and not by the browser, the exact parameters and fields will be exactly how the JavaScript decided with no surprises (outside of fixable JavaScript bugs). The remote peer can construct a connection object in the same manner as the offer peer. The SDP is extracted for its ICE credentials, where “setDescription” is called for the connection with the relevant information from the offer about the ICE userFrag, password and the ICE candidates can be set using “setRemoteConnectionCandidate”. The codecs and encryption algorithms are pulled from the SDP and “setConstraints” is called to indicate the “receive” constraints. If SSRC mapping was supported, the SSRC maps can be pulled out of the SDP and set using “setDescription” with a “receive” stream object provided.</t>

</section>
<section anchor="generating-an-answer" title="Generating an Answer">

<t>To construct answer, the ICE credentials are pulled from the connection object using the “getDescription”. The candidates will arrive on the “onconnectioncandidate” and can be placed in the SDP. The constraints for the “send” can be obtained by calling “getConstraints” for the “send” direction (and only mutually agreed codecs can be filtered in if desired). The “m=” line can be generated for the specific medias with the related “a=” codec mappings. If the SDP must generate SSRC mappings, the “getDescription” method can be used to obtain the mapping information in order to generate the various SDP SSRC entries in the answer.</t>

<t>The remote peer can be put into the “negotiated” state.</t>

</section>
<section anchor="parsing-an-answer" title="Parsing an Answer">

<t>When a peer in the offer state receives an answer, the peer must parse the answer. The first step is to parse out the SDP information as per the expectations of how it was generated. Since the offer was constructed with JavaScript and not by the browser, the exact parameters and fields will be exactly how the JavaScript decided with no surprises (outside of fixable JavaScript bugs). The peer has a connection object already. The SDP is extracted for its ICE credentials, where “setDescription” is called for the connection with the relevant information from the answer about the ICE userFrag, password and the ICE candidates can be set using “setRemoteConnectionCandidate”. The codecs and encryption algorithms are pulled from the SDP and “setConstraints” is called to indicate the “receive” constraints. If SSRC mapping was supported, the SSRC maps can be pulled out of the SDP and set using “setDescription” with a “receive” stream object provided.</t>

<t>The peer can be put into the “negotiated” state.</t>

</section>
<section anchor="use-of-provisional-answers" title="Use of Provisional Answers">

<t>In the object model, any connection can be forked (<xref target="interactionforking"/>) at any time. If a provisional answer is needed as another answer has arrived from an offer, the developer only needs to call the “fork” method on the connection. The developer will then have a connection which can be independently managed with a unique set of ICE candidates, constraints, encryption algorithms, and streams. Each forked connection is its own object and thus allows for independent negotiation with each forked peer.</t>

</section>
<section anchor="rollback" title="Rollback">

<t>As all the descriptions and constraints for each object can be maintained easily in an offer / answer state machine, the state machine can obtain all this information prior to constructing a new offer with new information. If the offer is rejected, the state can be rolled back to the previous state immediately, or, alternatively a new state can be applied only when an offer has been accepted. The browser does not need to know the state machine or the previous states, as all of this information can easily be set from JavaScript.</t>

</section>
<section anchor="configurable-sdp-parameters" title="Configurable SDP Parameters">

<t>Many SIP providers have custom SDP options and extensions. By allowing the SDP to be generated by JavaScript, the SDP extensions can be placed inside the SDP, without petitioning the browser vendor to make a change.</t>

</section>
<section anchor="sdp-offer-answer-state-machine-in-js" title="SDP Offer / Answer State Machine in JS">

<t>There is nothing special about an offer / answer state machine. The state machine can just as easily be defined in JavaScript as it can by the browser’s internal language. The difference is that fixes in the state machine with JavaScript can be applied dynamically whereas fixes to mistakes in the browser’s state machine are impossible until a browser update is released. At best a mistake in the browser can be “worked around”. JavaScript can be made to follow the same rules, requirements and expectations as native code, except it becomes optional for JavaScript developers, rather than mandating the state machine be followed for all signaling protocols (even those that do not want offer / answer).</t>

</section>
</section>
<section anchor="one-side-constraints" title="One-side Constraints">

<t>Another model for negotiation is “one-sided” constraints negotiation. In this model, each peer derives a set of “receive” constraints, which are set to the remote peer. Each peer is allowed to update their respective “receive” constraints at any time, which must be adhered by the remote party. This is useful to be able to send streams at will without requiring constant back and forth “offer”, “answer’ and “negotiated” states.</t>

<t>To perform this model, each side obtains its “receive” constraints using “getDescription” on the “receive” direction. The constraints information is then mutually exchanged as needed. The ICE candidate information is only exchanged upon start and the session lasts for the lifetime of the connection. Imposing a state machine like offer / answer hampers the simplicity of this signaling model. Whereas, SDP requires that the offer and answer contain the “send” constraints and not the “receive” constraints. To make this work with offer / answer and SDP requires a fair amount of SDP jerry-rigging (see <xref target="WebRTCJSObjExamples"/> for an example).</t>

</section>
<section anchor="xmpp" title="XMPP">

<t>XMPP using Jingle <xref target="Jingle"/> as a signaling mechanism. XMPP requires no SDP at all and uses XML as the mechanism for expressing constraints. By allowing XMPP to directly obtain structured data in JavaScript as well as direct control over the objects without imposing signaling mandates, XMPP implementations are free of the burden imposed with parsing and generating an unfamiliar SDP format, or adhering to the SIP definition of offer / answer, rather than adhering to the Jingle state machine.</t>

</section>
<section anchor="interactionforking" title="Interactions With Forking">

<t>Some signaling scenarios allow forking. With forking, an offer for a connection is made, but multiple peers might answer to the request to connect. For example, Alice might call Bob but Bob has two devices so both of Bob’s devices might answer. The answers can arrive at any time after the offer to connect request has been made. For example, SIP <xref target="RFC3261"/> defines “Parallel Search”, as well as “Sequential Search”. The browser must support forking by allowing a connection object to become forked at any time. This allows each connection to share common ICE userFrag and password credentials with the constraints defaulted identically, but each fork is allowed to negotiate its own ICE candidates, constraints, connection and stream descriptions. By doing so, the JavaScript developer can fully support signaling protocols where the forking is allowed, such as SIP.</t>

<section anchor="sequentialforking" title="Sequential Forking">

<t>As the offer / answer state machine is not imposed on a WebRTC JavaScript object model, there is no need to provide provisional answers in the state machine. A provisional answer is an answer that is temporarily accepted until the final answer is determined. Each answer has it’s own fork, and the various forks can be handled independently. Once the final sequential answer arrives, all the other connections can be disconnected.</t>

</section>
<section anchor="parallelforking" title="Parallel Forking">

<t>As the offer / answer state machine is not imposed on a WebRTC JavaScript object model, and forking is supported, parallel forking is also supported. Each answer has it’s own fork, and the various forks can be managed independently. There is no need to disconnect any fork, and each connections’ constraints, descriptions, streams and lifetime is entirely in the control of the JavaScript application.</t>

</section>
</section>
<section anchor="session-rehydration" title="Session Rehydration">

<t>The JSEP draft <xref target="I-D.ietf-rtcweb-jsep"/> described session rehydration as follows:
“In the event that the local application state is reinitialized, either due to a user reload of the page, or a decision within the application to reload itself (perhaps to update to a new version), it is possible to keep an existing session alive, via a process called “rehydration”.  The explicit goal of rehydration is to carry out this session resumption with no interaction with the remote side other than normal call signaling messages.”</t>

<t>In order for rehydration to work the current state of the connections must persist somewhere outside of the browser page’s context. To support reydration, a developer’s JavaScript must be capable of re-creating the stream and connection objects as per the previous persisted state, including but not limited to, all candidate negotiations, all connection establishments, all active streams and the relationships between streams, connections and sockets.</t>

<t>Further, the browser must maintain a reasonable lifetime for which JavaScript is allowed to reconnect to these objects with appropriate security precautions to ensure the objects cannot be hijacked by an unauthorized page containing malicious JavaScript.</t>

<t>The exact mechanism and API for these near-death object resurrections falls within the scope of the W3C and does not impact the overall concepts and design described in this draft, as long as the browser allows the RTC objects to be resurrected exactly in their previous states prior to a page reload, and JavaScript security tenants are adhered.</t>

</section>
</section>
<section anchor="interface" title="Interface">

<t>This section details the basic operations that must be present to implement the RTC JavaScript Object Model functionality.  The actual API exposed in the W3C API may have somewhat different syntax, but should map easily to these concepts.</t>

<section anchor="object-rtc-global-methods" title="Object RTC Global Methods">

<section anchor="getfeatures" title="getFeatures">

<t>The browser must supply a method to obtain well defined feature sets that are supported by the RTC engine (see <xref target="objfeaturediscovery"/>).</t>

</section>
<section anchor="getconstraints" title="getConstraints">

<t>The browser must supply a method to obtain the default system constraints (see <xref target="objconstraints"/>).</t>

</section>
</section>
<section anchor="mediasocket" title="MediaSocket">

<t>The media socket object is responsible for sending RTP packets over the wire and providing raw connectivity to the network, including setting up connections with related stun and turn servers.</t>

<t>The media socket can be constructed with a few options specified by the developer’s JavaScript:</t>

<t><list style='symbols'>
  <t>flag to mux RTP and RTCP on a single port (default), or to use two independent ports, one for RTP and the other for RTCP (ports should be sequential, with the first port being even)</t>
  <t>list of optional stun servers to perform reflexive IP discovery (default, browser specific)</t>
  <t>list of optional turn servers to act as relays (default, browser specific)</t>
  <t>restrictive list of media “kinds” (see MediaStreamTrack <xref target="MediaCapture"/>) to restrict the socket to only carry certain kinds of media (default, no restriction)</t>
  <t>alternative public / private key pair (default, internal browser generated public / private key)</t>
</list></t>

<t>The browser must not allow access via JavaScript to any public / private keys internally generated by the browser, but must allow a developer’s JavaScript to provide an alternative public / private key pair.</t>

<t>The fingerprint property representing the hash of the public key on a socket object supporting DTLS <xref target="RFC6347"/> must be retrievable (for further discussion <xref target="dtlssrtp"/>).</t>

</section>
<section anchor="datasocket" title="DataSocket">

<t>The data socket object is responsible for sending data streams over the wire and providing raw connectivity to the network, and this includes setting up connections with related stun and turn servers.</t>

<t>The data socket can be constructed with a few options specified by the developer’s JavaScript:</t>

<t><list style='symbols'>
  <t>list of optional stun servers to perform reflexive IP discovery (default, browser specific)</t>
  <t>list of optional turn servers to act as relays (default, browser specific)</t>
  <t>alternative public / private key pair (default, internal browser generated public / private key)</t>
</list></t>

<t>The browser must not allow access via JavaScript to any public / private keys internally generated by the browser, but must allow a developer’s JavaScript to provide an alternative public / private key pair.</t>

<t>The fingerprint property representing the hash of the public key on a socket object supporting DTLS <xref target="RFC6347"/> must be retrievable.</t>

</section>
<section anchor="mediadatamuxsocket" title="MediaDataMuxSocket">

<t>The media / data mux socket object is a multiplexed socket object allowing either RTP or DTLS/SCTP <xref target="RFC6347"/>/<xref target="RFC4960"/> information to be carried on the same port. The object carries the same options and properties as both the media socket object (<xref target="mediasocket"/>) and the data socket object (<xref target="datasocket"/>).</t>

</section>
<section anchor="connection" title="Connection">

<t>The connection object represents the interface to a connection between the local browser and a remote peer (or server).</t>

<section anchor="construction" title="Construction">

<t>The connection object allows for the following optional information to be specified on construction:</t>

<t><list style='symbols'>
  <t>list of sockets (if none provided, default MediaDataMuxSocket (<xref target="mediadatamuxsocket"/>) with id “default” is created)</t>
  <t>activate state (default is “true”, i.e. active, “false” therefor would mean that streams are prevented from sending or receiving)</t>
  <t>send constraints - list of codec, algorithms and “other” constraint restrictions placed upon send streams by default (defaults to system constraints)</t>
  <t>receive constraints - list of codec, algorithms and “other” constraint restrictions placed upon send streams by default (defaults to system constraints)</t>
</list></t>

<t>The constructor is also responsible for setting up the following information:</t>

<t><list style='symbols'>
  <t>context id - all connections that are forked from the same root share the same context id (where as each connection still has a unique id)</t>
  <t>secret - a randomly generated secret for the connection, which is shared by all forked connections</t>
  <t>cname - optionally passed into as an option (default by the system according Guidelines for Choosing RTP Control Protocol (RTCP) Canonical Names (CNAMEs) (<xref target="I-D.ietf-avtcore-6222bis"/>))</t>
</list></t>

<t>The context id and the secret serve a dual role as being used for the ICE <xref target="RFC5245"/> userFrag and password during ICE connectivity checks, and may be used for other purposes. The secret must not be compromised by a developer’s JavaScript but the value must be available to JavaScript to facilitate alternative signaling protocols.</t>

</section>
<section anchor="onconnectioncandidate" title="onconnectioncandidate">

<t>The “onconnectioncandidate” event must fire to allow a developer’s JavaScript to receive a discovered connection candidate. The developer’s JavaScript is responsible for signaling the candidate to a remote peer.</t>

</section>
<section anchor="onconnectioncandidatesdone" title="onconnectioncandidatesdone">

<t>The “onconnectioncandidatesdone” event must fire to allow a developer’s JavaScript to be notified when all candidate discoveries have completed. This is required to allow for signaling protocols that cannot or do not wish to trickle ICE candidates as they are discovered. The developer’s JavaScript is responsible for signaling the candidates to a remote peer.</t>

</section>
<section anchor="onactiveconnectioncandidate" title="onactiveconnectioncandidate">

<t>The “onactiveconnectioncandidate” event must fire to allow a developer’s JavaScript to be notified which active candidate local / remote pairing the connection is using. This is required to allow for signaling protocols that may be required to report the active connection candidates.</t>

</section>
<section anchor="onconnected" title="onconnected">

<t>The “onconnected” event must fire to allow a developer’s JavaScript to be notified when a connection is connected. This is required to allow signaling protocols to start utilizing the established connection.</t>

</section>
<section anchor="ondisconnected" title="ondisconnected">

<t>The “ondisconnected” event must fire to allow a developer’s JavaScript to be notified when a connection is disconnected. This is required to allow signaling protocols to react to a disconnection in whatever manner is appropriate given the reason why the connection failed as part of the event. If a single socket should fail then the entire connection will disconnect. If that behavior is undesirable, the developer may create multiple connections rather than a single connection so that a failure on one socket does not affect another socket.</t>

</section>
<section anchor="onstreamconnected" title="onstreamconnected">

<t>The “onstreamconnected” event must fire to allow a developer’s JavaScript to be notified when a stream has connected. This is required to allow signaling protocols to have knowledge when media or data can flow between peers.</t>

</section>
<section anchor="onstreamdisconnected" title="onstreamdisconnected">

<t>The “onstreamdisconnected” event must fire to allow a developer’s JavaScript to be notified when a stream has disconnected. This is required to allow signaling protocols to have knowledge when media or data flowing between peers has stopped.</t>

</section>
<section anchor="onsteamreport" title="onsteamreport">

<t>The “onsteamreport” event may fire to allow a developer’s JavaScript to be notified of stream’s conditions or statistics. The signaling protocol may wish to react based upon stream conditions, for example, to choose a downgraded stream when bandwidth is limited.</t>

</section>
<section anchor="ontrackconnected" title="ontrackconnected">

<t>The “ontrackconnected” event must fire to allow a developer’s JavaScript to be notified when a media stream track has connected. This is required to allow signaling protocols to have knowledge when individual media stream tracks have connected.</t>

</section>
<section anchor="ontrackdisconnected" title="ontrackdisconnected">

<t>The “ontrackdisconnected” event must fire to allow a developer’s JavaScript to be notified when a media stream track has disconnected. This is required to allow signaling protocols to have knowledge when individual media stream tracks have disconnected.</t>

</section>
<section anchor="ontrackcontributors" title="ontrackcontributors">

<t>The “ontrackcontributors” event must fire to allow a developer’s JavaScript to be notified when the contributing sources for a media stream track have changed. This is required to allow signaling protocols to have knowledge of the contributors active in a given media stream, for example, in a conferencing scenario. Since the contributing sources can change per packet, the browser may impose reasonable rules on how frequently this event will fire.</t>

</section>
<section anchor="ontrackreport" title="ontrackreport">

<t>The “ontrackreport” event may fire to allow a developer’s JavaScript to be notified of media stream track’s conditions or statistics. The signaling protocol may wish to react based upon media stream track conditions, for example, to choose a downgraded stream when bandwidth is limited.</t>

</section>
<section anchor="activate" title="activate">

<t>This method allows the developer’s JavaScript to temporarily “pause” all media flowing in and out of the RTC engine. This may be required in some signaling scenarios where the setup process is more involved and the setup requires better synchronization.</t>

</section>
<section anchor="disconnect" title="disconnect">

<t>This method allows the developer’s JavaScript to disconnect the connection. This is required by signaling protocols to tear down connections.</t>

</section>
<section anchor="setremoteconnectioncandidate" title="setRemoteConnectionCandidate">

<t>This method allows the developer’s JavaScript to notify the connection about a remote peer’s discovered connection candidate as part of the connection setup process.</t>

</section>
<section anchor="getdescription" title="getDescription">

<t>This method allows the developer’s JavaScript to obtain description information on connection (<xref target="objconnectiondescription"/>), media streams (<xref target="objstreamdescriptions"/>), and other streams like data streams (<xref target="objdatastreamdescription"/>). These descriptions must be obtainable in order to correctly signal information about connections and streams.</t>

</section>
<section anchor="setdescription" title="setDescription">

<t>This method allows the developer’s JavaScript to set the description information on a connection (<xref target="objconnectiondescription"/>), media streams (<xref target="objstreamdescriptions"/>), and other streams like data streams (<xref target="objdatastreamdescription"/>). These descriptions must be changeable in order to allow for a variety of signaling scenarios, or when the description for the remote peer must be set on the local peer in order to correctly establish communications.</t>

</section>
<section anchor="getconstraints-1" title="getConstraints">

<t>This method allows the developer’s JavaScript to obtain the current restrictions on “send” or “receive” connections, streams, or individual tracks mapped into an RTP stream. This method is needed for the signaling protocol to obtain the current restriction placed on media streams for codecs, encryption algorithms, or other extension constraints.</t>

</section>
<section anchor="setconstraints" title="setConstraints">

<t>This method allows the developer’s JavaScript to set the current restrictions on “send” or “receive” connections, streams, or individual tracks mapped into an RTP stream. This method is needed to set the current restrictions placed on media streams for codecs, encryption algorithms, or other extension constraints by signaling protocols.</t>

</section>
<section anchor="sendstream" title="sendStream">

<t>This method allows the developer’s JavaScript to send a stream to the remote peer, or remove a stream from sending with “false” specified. This is required to allow the signaling protocol to control when a stream is to be sent to the remote peer, and when a stream is to stop sending to the remote peer.</t>

</section>
<section anchor="receivestream" title="receiveStream">

<t>This method allows the developer’s JavaScript to receive a stream from the remote peer, or to stop receiving a stream with “false” specified. The receive stream must allow signaling protocols to use either a loose description (<xref target="loosedescriptions"/>), or with a specific stream description obtained from the remote party calling “getDescription(stream)” and signaling this information. By allowing for either loose, or specific descriptions, the browser allows a variety of signaling protocols to be implementable.</t>

</section>
<section anchor="fork" title="fork">

<t>This method allows the developer’s JavaScript to offer a single connection’s description to multiple peers, allowing for multiple connection responses in cases of signaling protocols that allow sequential forking (<xref target="sequentialforking"/>) or parallel forking (<xref target="parallelforking"/>). Only the first connection (<xref target="objconnection"/>) object created must receive all the discovered connection candidates, but each forked connection can be given a unique set of remote connection candidates from each potentially responding peer. The streams attached and the setup for each forked connection must be unique. The constraints are copied from the original forked connection but can set unique per fork. Each forked connection object must be considered a unique object, except that it shares the same originating connection context, and sockets.</t>

</section>
<section anchor="stream-relationship-management" title="Stream Relationship Management">

<t>The connection object has relationships to streams, e.g. media (<xref target="MediaCapture"/>) or data streams (<xref target="datastream"/>). A stream can either be sent, or received on a single connection but should not be both, even if the stream is bi-directional (e.g. a data stream). A data stream (<xref target="datastream"/>) only needs one peer to send and the other will receive the “onstreamconnected” event. The recommended method for performing loopback media (where media is sent back where it is received from) is to create a new stream with the old tracks in those rare use cases, as this allows signaling protocol implementation to be absolutely clear as to which direction constraints are being applied when applied at a media stream level.</t>

</section>
</section>
<section anchor="example-dtmfmediastreamtrack-specialization" title="Example: DTMFMediaStreamTrack Specialization">

<t>The DTMF media stream track is an example of a specialized type of media stream track <xref target="MediaCapture"/> that can be implemented to facilitate IVR interactions via DTMF <xref target="RFC4733"/>. This example is illustrates the flexibility of adding new specialized object types without affecting, or expanding the behaviors (or methods) of other existing objects. Only if a JavaScript developer wishes to use these extension objects will they receive the additional behaviors. The exact features and support requirements for DTMF should be decided by the RTCWEB WG. This merely demonstrates what could be implemented, not what must be implemented.</t>

<section anchor="construction-1" title="Construction">

<t>The DTMF media stream track should be constructed as a loose object that can be attached to an existing media stream object. By default, the browser must mux the DTMF track with the same SSRC as the first audio track in the stream when sending a stream as per the rules defined in RFC4733 <xref target="RFC4733"/>. As DTMF represents a different “kind” of media and has a unique codec attribute, the DTMF track can be easily demuxed into a unique DTMF media stream track by the receiving peer.</t>

</section>
<section anchor="starttone" title="startTone">

<t>This is an example method allowing the developer’s JavaScript to start playing a DTMF tone over the media stream track.</t>

</section>
<section anchor="stoptone" title="stopTone">

<t>This is an example method allowing the developer’s JavaScript to stop playing a DTMF tone over the media stream track.</t>

</section>
<section anchor="playtones" title="playTones">

<t>This is an example method allowing the developer’s JavaScript to easily pre-play an array of DTMF tones using equal or specific timings.</t>

</section>
<section anchor="flush" title="flush">

<t>This is an example method allowing the developer’s JavaScript to easily stop all pre-playing DTMF tones.</t>

</section>
<section anchor="ontonestart" title="ontonestart">

<t>This is an example event the developer’s JavaScript could receive to be notified that a DTMF tone has started playing on a DTMF media stream track (if support for incoming DTMF events is decided to be optional / mandatory in the browser).</t>

</section>
<section anchor="ontonestop" title="ontonestop">

<t>This is an example event the developer’s JavaScript could receive to be notified that a DTMF tone has stopped playing on a DTMF media stream track (if support for incoming DTMF events is desired to be optional / mandatory in the browser).</t>

</section>
</section>
<section anchor="example-datastream-specialization" title="Example: DataStream Specialization">

<t>The data stream is an example of a specialized type of media stream <xref target="MediaCapture"/> that can be implemented to facilitate arbitrary data transmission between peers. This example illustrates the flexibility of adding new specialized object types without affecting, or expanding the behaviors (or methods) of other existing objects. Only if a JavaScript developer wishes to use these extension objects will they receive the additional behaviors. Data streams are useful in a variety of signaling scenarios and informational where information can be transmitted directly peer-to-peer, e.g. file transfer.</t>

<section anchor="construction-2" title="Construction">

<t>In the example, the data stream has an option to specify the reliability of the stream so the stream can be sent in an “envelop” or “fifo” fashion. This is required to allow for alternative signaling methods that wish to send fast updates to a remote peer but may be unreliably sent, or reliably sent in a first-in-first-out fashion. As this is an example only, the actual implementation can be expanded to contain whatever features the RTCWEB WG and W3C ultimately decide upon for data streams.</t>

</section>
<section anchor="onreceive" title="onreceive">

<t>This is an example event the developer’s JavaScript could receive to be notified of incoming data.</t>

</section>
<section anchor="send" title="send">

<t>This is an example method the developer’s JavaScript could call to send data over the data stream.</t>

</section>
<section anchor="close" title="close">

<t>This is an example method the developer’s JavaScript could call to close the data stream.</t>

</section>
</section>
</section>
<section anchor="comparison-to-other-approaches" title="Comparison to Other Approaches">

<section anchor="jsep" title="JSEP">

<t>The main differences in the WebRTC Object vs JSEP:</t>

<t><list style='numbers'>
  <t>JSEP requires an all-encompassing complete description of media, transports, constraints and streams.</t>
  <t>Enforces an offer / answer state machine upon all signaling.</t>
  <t>Enforces SDP offer / answer negotiation.</t>
  <t>Requires other signaling protocols to transcode from an unfamiliar SDP format.</t>
  <t>Offers little granular control over the contents of the SDP.</t>
  <t>Allows simple WebRTC scenarios to be easily implemented.</t>
  <t>Has a free format where behavior expectations for future additions are unknown, or what aspects of the SDP are allowed to be manipulated or not.</t>
  <t>Allows SIP implementations to interface with the browser.</t>
</list></t>

<t>Where as WebRTC JavaScript Object Model:</t>

<t><list style='numbers'>
  <t>Modularizes the information needed into independent components.</t>
  <t>Enforces no signaling mandates, other than candidate connectivity checking.</t>
  <t>Treats constraints as independent and updateable as signaling protocols might require.</t>
  <t>Allows JavaScript developers to utilize well known JavaScript structures to obtain information.</t>
  <t>Exposes all the content in a granular fashion.</t>
  <t>Allows simple WebRTC scenarios to be easily implemented.</t>
  <t>Has strict rules as to what information is allowed for each object, and methods / events have testable compliance behaviors that can be established.</t>
  <t>Allows SIP implementations to interface with the browser with more predictable behaviors.</t>
</list></t>

<t>Overall, the WebRTC JavaScript Object Model is more flexible but maintains the same ease of use for basic use cases.</t>

</section>
<section anchor="plana-or-planb" title="PlanA or PlanB">

<t>Plan A <xref target="I-D.roach-rtcweb-plan-a"/>, Plan B <xref target="I-D.uberti-rtcweb-plan"/>, and NoPlan <xref target="I-D.ivov-rtcweb-noplan"/> are all methods for dealing with large number of media streams and how they must be expressly described in SDP, or negotiated along side SDP. Each have their own merits and pitfalls. However, since this is SDP / SIP specific the RTCWEB WG does not need to be involved in these discussions. All three of these models can be expressed in an object model, and should any additional description information be needed, the object model can be extended to accommodate accordingly.</t>

</section>
<section anchor="noplan" title="NoPlan">

<t>NoPlan is a hybrid approach where some information is carried over SDP, the SDP offer / answer state machine still applies but many of the other description information exists outside the SDP. While a step in the right direction, this creates a lot of ambiguity for responsibilities as well as what should be adhered and what should not. More importantly, the ambiguity exists for extensions. Are they part of SDP, or not? Had NoPlan been taken to the full extent to replace SDP and offer / answer, this solution would be best. In many ways, this is what the object model proposed in this draft is doing.</t>

</section>
</section>
<section anchor="requirements-compliance-statement" title="Requirements Compliance Statement">

<t>This draft is compliant to the following relevant requirements specified in Web Real-Time Communication Use-cases and Requirements <xref target="I-D.ietf-rtcweb-use-cases-and-requirements"/>:</t>

<t><list style='symbols'>
  <t>F2, F3, F4, F10, F11, F12, F16, F19, F20, F22, F25, F26, F27, F29, F31, F32, F33, F35, F36, F37, F38, F39</t>
</list></t>

<t>Whereas the following requirements are not applicable to this draft (either exist outside the object model or are an internal feature of an internal RTC engine):</t>

<t><list style='symbols'>
  <t>F1, F5, F7, F8, F9, F13, F14, F15, F17, F18, F21, F23, F24, F28, F30, F34</t>
</list></t>

<t>Appropriate design consideration was given to the relevant sections in the “Web Real-Time Communication (WebRTC) - Media Transport and Use of RTP <xref target="I-D.ietf-rtcweb-rtp-usage"/>” draft.</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>As stated best in JSEP draft <xref target="I-D.ietf-rtcweb-jsep"/> in the security considerations section “The intent of the WebRTC protocol suite is to provide an environment that is securable by default: all media is encrypted, keys are exchanged in a secure fashion, and the Javascript API includes functions that can be used to verify the identity of communication partners.”</t>

<section anchor="dtls" title="DTLS">

<section anchor="fingerprintresponsibility" title="DTLS Fingerprint Responsibility">

<t>When DTLS <xref target="RFC6347"/> is used for a connection (<xref target="objconnection"/>), the DTLS fingerprint(s) must be signaled by the developer in such a way that the hash cannot be modified during transit between connecting peers during a signaling exchange, and / or alternatively, the ownership of the fingerprint(s) must be cryptographically proven to correlate to the identity of the connected peer. Failure to perform a secure exchange of fingerprint(s) or a correlation of the fingerprint(s) to the remote peer’s identity may result in a compromised DTLS channel. The responsibility for ensuring a non-compromised DTLS channel fingerprint must be left to the JavaScript developer and signaling path to handle.</t>

<t>The browser must expose the fingerprints involved from the Connection <xref target="objconnection"/> object and from each socket that uses DTLS <xref target="objsocket"/>.</t>

</section>
<section anchor="idp" title="IdP">

<t>The identity provider model has not be mandated. The model is far away from completion, and the round trips to perform validation before a stream can be rendered is not desirable. IdP requires an identity model that might not exist conceptually for many web services. Further, in many simple cases this model is not required as a WebSocket with TLS can be used to exchange fingerprints for a private service providing the same level of trust from the provider since the fingerprints are exchanged in a private manner. IdP also suggest domain federation is possible but federation is only possible if two clients run the same JavaScript signaling model on both ends and signaling is federated across domains. The IdP federation identity model is complex for web services that wish to perform simple WebRTC use cases.</t>

</section>
<section anchor="jscertificates" title="JavaScript Provided DTLS Certificates">

<t>Controversy exists in allowing JavaScript to provide an alternate certificate to the browser’s private certificate. Most of the controversy is over how to display the correct level of security, since allowing JavaScript to provide a certificate may weaken security. There are two forms of this weakness: malicious or accidental.</t>

<t>Preventing weakness due to a provider intentionally using malicious JavaScript is virtually impossible. The browser could have 100% on-the-wire security and still be compromised. The browser is in complete control over where to send streams (so long as ICE permission is granted). In other words, malicious JavaScript code could duplicate user generated streams to whatever destination they choose, which causes on-the-wire security to be essentially meaningless.</t>

<t>If the goal is preventing accidental errors in security, a custom certificate is not the only weak area in code to cause accidental compromises. For example, directing the stream to the wrong location by mistaken negotiation is possible, as are mistakes in server security infrastructure, along with the potential for basic mistakes like JavaScript choosing to contact the wrong party in the first place. Prevention against accidents is a lofty goal, but likely unobtainable without many additional usage restrictions.</t>

<t>The RTCWEB WG must come to a decision to allow this feature or not.</t>

</section>
<section anchor="dtlssrtp" title="DTLS / SRTP vs SDES / SRTP">

<t>Auto-keying for RTP could be done through a DTLS handshakes extensions as opposed to using SDES. If DTLS becomes the mandated method to perform media key negotiation then the implementation bar is raised for what a remote device must support to communicate, and many legacy devices and networks do not support this feature. DTLS without an absolutely foolproof man-in-the-middle attack prevention scheme (i.e. fingerprint validation, see <xref target="idp"/>) provides little security if the stream can be intercepted, and may in fact be weaker than allowing the browsers to exchange SDES credentials privately during their negotiation (e.g. keying via an HTTPS proxy). The final decision to mandate, recommend or allow for media key negotiation over DTLS must be made by the RTCWEB WG before any RTC JavaScript interface can be completed.</t>

</section>
</section>
</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='I-D.ietf-rtcweb-use-cases-and-requirements'>
<front>
<title>Web Real-Time Communication Use-cases and Requirements</title>

<author initials='C' surname='Holmberg' fullname='Christer Holmberg'>
    <organization />
</author>

<author initials='S' surname='Hakansson' fullname='Stefan Hakansson'>
    <organization />
</author>

<author initials='G' surname='Eriksson' fullname='Goran Eriksson'>
    <organization />
</author>

<date month='June' day='27' year='2013' />

<abstract><t>This document describes web based real-time communication use-cases. Requirements on the browser functionality are derived from use-cases.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-rtcweb-use-cases-and-requirements-11' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-rtcweb-use-cases-and-requirements-11.txt' />
</reference>



<reference anchor='I-D.ietf-rtcweb-rtp-usage'>
<front>
<title>Web Real-Time Communication (WebRTC): Media Transport and Use of RTP</title>

<author initials='C' surname='Perkins' fullname='Colin Perkins'>
    <organization />
</author>

<author initials='M' surname='Westerlund' fullname='Magnus Westerlund'>
    <organization />
</author>

<author initials='J' surname='Ott' fullname='Joerg Ott'>
    <organization />
</author>

<date month='February' day='25' year='2013' />

<abstract><t>The Web Real-Time Communication (WebRTC) framework provides support for direct interactive rich communication using audio, video, text, collaboration, games, etc. between two peers' web-browsers.  This memo describes the media transport aspects of the WebRTC framework. It specifies how the Real-time Transport Protocol (RTP) is used in the WebRTC context, and gives requirements for which RTP features, profiles, and extensions need to be supported.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-rtcweb-rtp-usage-06' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-rtcweb-rtp-usage-06.txt' />
</reference>



<reference anchor='RFC3550'>

<front>
<title>RTP: A Transport Protocol for Real-Time Applications</title>
<author initials='H.' surname='Schulzrinne' fullname='H. Schulzrinne'>
<organization /></author>
<author initials='S.' surname='Casner' fullname='S. Casner'>
<organization /></author>
<author initials='R.' surname='Frederick' fullname='R. Frederick'>
<organization /></author>
<author initials='V.' surname='Jacobson' fullname='V. Jacobson'>
<organization /></author>
<date year='2003' month='July' />
<abstract>
<t>This memorandum describes RTP, the real-time transport protocol.  RTP provides end-to-end network transport functions suitable for applications transmitting real-time data, such as audio, video or simulation data, over multicast or unicast network services.  RTP does not address resource reservation and does not guarantee quality-of- service for real-time services.  The data transport is augmented by a control protocol (RTCP) to allow monitoring of the data delivery in a manner scalable to large multicast networks, and to provide minimal control and identification functionality.  RTP and RTCP are designed to be independent of the underlying transport and network layers.  The protocol supports the use of RTP-level translators and mixers.  Most of the text in this memorandum is identical to RFC 1889 which it obsoletes.  There are no changes in the packet formats on the wire, only changes to the rules and algorithms governing how the protocol is used.  The biggest change is an enhancement to the scalable timer algorithm for calculating when to send RTCP packets in order to minimize transmission in excess of the intended rate when many participants join a session simultaneously. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='STD' value='64' />
<seriesInfo name='RFC' value='3550' />
<format type='TXT' octets='259985' target='http://www.rfc-editor.org/rfc/rfc3550.txt' />
<format type='PS' octets='630740' target='http://www.rfc-editor.org/rfc/rfc3550.ps' />
<format type='PDF' octets='504117' target='http://www.rfc-editor.org/rfc/rfc3550.pdf' />
</reference>



<reference anchor='RFC5245'>

<front>
<title>Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols</title>
<author initials='J.' surname='Rosenberg' fullname='J. Rosenberg'>
<organization /></author>
<date year='2010' month='April' />
<abstract>
<t>This document describes a protocol for Network Address Translator (NAT) traversal for UDP-based multimedia sessions established with the offer/answer model.  This protocol is called Interactive Connectivity Establishment (ICE).  ICE makes use of the Session Traversal Utilities for NAT (STUN) protocol and its extension, Traversal Using Relay NAT (TURN).  ICE can be used by any protocol utilizing the offer/answer model, such as the Session Initiation Protocol (SIP). [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5245' />
<format type='TXT' octets='285120' target='http://www.rfc-editor.org/rfc/rfc5245.txt' />
</reference>



<reference anchor='I-D.rescorla-mmusic-ice-trickle'>
<front>
<title>Trickle ICE: Incremental Provisioning of Candidates for the Interactive Connectivity Establishment (ICE) Protocol</title>

<author initials='E' surname='Rescorla' fullname='Eric Rescorla'>
    <organization />
</author>

<author initials='J' surname='Uberti' fullname='Justin Uberti'>
    <organization />
</author>

<author initials='E' surname='Ivov' fullname='Emil Ivov'>
    <organization />
</author>

<date month='October' day='22' year='2012' />

<abstract><t>This document describes an extension to the Interactive Connectivity Establishment (ICE) protocol that allows ICE agents to send and receive candidates incrementally rather than exchanging complete lists.  With such incremental provisioning, ICE agents can begin connectivity checks while they are still gathering candidates and considerably shorten the time necessary for ICE processing to complete.  The above mechanism is also referred to as "trickle ICE".</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-rescorla-mmusic-ice-trickle-01' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-rescorla-mmusic-ice-trickle-01.txt' />
</reference>


<reference anchor="MediaStreams" target="http://www.w3.org/TR/2013/WD-mediacapture-streams-20130516/">
  <front>
    <title>Media Capture and Streams</title>
    <author initials="D." surname="Burnett" fullname="Daniel C. Burnett">
      <organization></organization>
    </author>
    <date year="2013" month="March" day="16"/>
  </front>
</reference>


    </references>

    <references title='Informative References'>





<reference anchor='I-D.ietf-rtcweb-jsep'>
<front>
<title>Javascript Session Establishment Protocol</title>

<author initials='J' surname='Uberti' fullname='Justin Uberti'>
    <organization />
</author>

<author initials='C' surname='Jennings' fullname='Cullen Jennings'>
    <organization />
</author>

<date month='February' day='27' year='2013' />

<abstract><t>This document describes the mechanisms for allowing a Javascript application to fully control the signaling plane of a multimedia session via the interface specified in the W3C RTCPeerConnection API, and discusses how this relates to existing signaling protocols.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-rtcweb-jsep-03' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-rtcweb-jsep-03.txt' />
</reference>



<reference anchor='I-D.jesup-rtcweb-data-protocol'>
<front>
<title>WebRTC Data Channel Protocol</title>

<author initials='R' surname='Jesup' fullname='Randell Jesup'>
    <organization />
</author>

<author initials='S' surname='Loreto' fullname='Salvatore Loreto'>
    <organization />
</author>

<author initials='M' surname='Tuexen' fullname='Michael Tuexen'>
    <organization />
</author>

<date month='February' day='26' year='2013' />

<abstract><t>The Web Real-Time Communication (WebRTC) working group is charged to provide protocols to support for direct interactive rich communication using audio, video, and data between two peers' web- browsers.  This document specifies an actual (minor) protocol for how the JS-layer DataChannel objects provide the data channels between the peers.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-jesup-rtcweb-data-protocol-04' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-jesup-rtcweb-data-protocol-04.txt' />
</reference>



<reference anchor='I-D.raymond-rtcweb-webrtc-js-obj-api-rationale'>
<front>
<title>WebRTC JavaScript Object API Rationale</title>

<author initials='R' surname='Raymond' fullname='Robin Raymond'>
    <organization />
</author>

<author initials='E' surname='Lagerway' fullname='Erik Lagerway'>
    <organization />
</author>

<author initials='I' surname='Castillo' fullname='Inaki Castillo'>
    <organization />
</author>

<author initials='R' surname='Shpount' fullname='Roman Shpount'>
    <organization />
</author>

<date month='June' day='25' year='2013' />

<abstract><t>This document describes the reasons why a JavaScript Object API approach is a far better solution than using SDP [RFC4566] as a surface API for interfacing with WebRTC.  The document outlines the issues and pitfalls as well as use cases that are difficult (or impossible) with SDP with offer / answer [RFC3264], and explains the benefits and goals of an alternative JavaScript Object API approach.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-raymond-rtcweb-webrtc-js-obj-api-rationale-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-raymond-rtcweb-webrtc-js-obj-api-rationale-00.txt' />
</reference>



<reference anchor='I-D.ietf-avtcore-6222bis'>
<front>
<title>Guidelines for Choosing RTP Control Protocol (RTCP) Canonical Names (CNAMEs)</title>

<author initials='A' surname='Begen' fullname='Ali Begen'>
    <organization />
</author>

<author initials='C' surname='Perkins' fullname='Colin Perkins'>
    <organization />
</author>

<author initials='D' surname='Wing' fullname='Dan Wing'>
    <organization />
</author>

<author initials='E' surname='Rescorla' fullname='Eric Rescorla'>
    <organization />
</author>

<date month='June' day='19' year='2013' />

<abstract><t>The RTP Control Protocol (RTCP) Canonical Name (CNAME) is a persistent transport-level identifier for an RTP endpoint.  While the Synchronization Source (SSRC) identifier of an RTP endpoint may change if a collision is detected or when the RTP application is restarted, its RTCP CNAME is meant to stay unchanged, so that RTP endpoints can be uniquely identified and associated with their RTP media streams.  For proper functionality, RTCP CNAMEs should be unique within the participants of an RTP session.  However, the existing guidelines for choosing the RTCP CNAME provided in the RTP standard are insufficient to achieve this uniqueness.  RFC 6222 was published to update those guidelines to allow endpoints to choose unique RTCP CNAMEs. Unfortunately, later investigations showed that some parts of the new algorithms were unnecessarily complicated and/or ineffective.  This document addresses these concerns and replaces RFC 6222.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-avtcore-6222bis-04' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-avtcore-6222bis-04.txt' />
</reference>



<reference anchor='I-D.ietf-mmusic-sdpng'>
<front>
<title>Session Description and Capability Negotiation</title>

<author initials='D' surname='Kutscher' fullname='Dirk Kutscher'>
    <organization />
</author>

<author initials='J' surname='Ott' fullname='Joerg Ott'>
    <organization />
</author>

<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>

<date month='February' day='23' year='2005' />

<abstract><t>This document defines a language for describing multimedia sessions with respect to configuration parameters and capabilities of end-systems. The description language is independent of specific application scenarios (session announcement, session setup for interactive communication etc.) and is not limited to specific media types, capabilities, or configuration parameters.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-mmusic-sdpng-08' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-mmusic-sdpng-08.txt' />
</reference>



<reference anchor='I-D.roach-rtcweb-plan-a'>
<front>
<title>Using SDP with Large Numbers of Media Flows</title>

<author initials='A' surname='Roach' fullname='Adam Roach'>
    <organization />
</author>

<author initials='M' surname='Thomson' fullname='Martin Thomson'>
    <organization />
</author>

<date month='May' day='7' year='2013' />

<abstract><t>A recurrent theme in WebRTC has been the need to handle very large numbers of media flows.  Unfortunately, naive uses of SDP do not handle this case particularly well.  This document describes a modest set of extensions to SDP which allow it to cleanly handle arbitrary numbers of flows while still retaining a large degree of backward compatibility with existing and non-RTCWEB endpoints.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-roach-rtcweb-plan-a-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-roach-rtcweb-plan-a-00.txt' />
</reference>



<reference anchor='I-D.uberti-rtcweb-plan'>
<front>
<title>Plan B: a proposal for signaling multiple media sources in WebRTC.</title>

<author initials='J' surname='Uberti' fullname='Justin Uberti'>
    <organization />
</author>

<date month='May' day='2' year='2013' />

<abstract><t>This document explains how multiple media sources can be signaled in WebRTC using SDP, in a fashion that avoids many common problems and provides a simple control surface to the receiver.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-uberti-rtcweb-plan-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-uberti-rtcweb-plan-00.txt' />
</reference>



<reference anchor='I-D.ivov-rtcweb-noplan'>
<front>
<title>No Plan: Economical Use of the Offer/Answer Model in WebRTC Sessions with Multiple Media Sources</title>

<author initials='E' surname='Ivov' fullname='Emil Ivov'>
    <organization />
</author>

<author initials='E' surname='Marocco' fullname='Enrico Marocco'>
    <organization />
</author>

<author initials='P' surname='Thatcher' fullname='Peter Thatcher'>
    <organization />
</author>

<date month='June' day='17' year='2013' />

<abstract><t>This document describes a model for the lightweight use of SDP Offer/ Answer in WebRTC.  The goal is to minimize reliance on Offer/Answer exchanges in a WebRTC session and provide applications with the tools necessary to implement the signalling that they may need in a way that best fits their custom requirements and topologies.  This simplifies signalling of multiple media sources or providing RTP Synchronisation source (SSRC) identification in multi-party sessions. Another important goal of this model is to remove from clients topological constraints such as the requirement to know in advance all SSRC identifiers that they could potentially introduce in a particular session.  The model described here is similar to the one employed by the data channel JavaScript APIs in WebRTC, where methods are supported on PeerConnection without being reflected in SDP.  This document does not question the use of SDP and the Offer/Answer model or the value they have in terms of interoperability with legacy or other non-WebRTC devices.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ivov-rtcweb-noplan-01' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ivov-rtcweb-noplan-01.txt' />
</reference>


<reference anchor="WebRTC10" target="http://www.w3.org/TR/2012/WD-webrtc-20120821/">
  <front>
    <title>WebRTC 1.0 Real-time Communication Between Browsers</title>
    <author initials="A." surname="Bergkvist" fullname="Adam Bergkvist">
      <organization></organization>
    </author>
    <date year="2012" month="August" day="21"/>
  </front>
</reference>
<reference anchor="MediaCapture" target="http://www.w3.org/TR/2013/WD-mediacapture-streams-20130516/">
  <front>
    <title>Media Capture and Streams</title>
    <author initials="D." surname="Burnett" fullname="Daniel C. Burnett">
      <organization></organization>
    </author>
    <date year="2013" month="May" day="29"/>
  </front>
</reference>
<reference anchor="WebRTCJSObjExamples" target="http://tools.ietf.org/html/draft-raymond-rtcweb-webrtc-js-obj-rtc-examples-00">
  <front>
    <title>WebRTC JavaScript Object RTC Examples</title>
    <author initials="R." surname="Raymond" fullname="Robin Raymond">
      <organization></organization>
    </author>
    <date year="2013" month="July" day="05"/>
  </front>
</reference>
<reference anchor="Jingle" target="http://xmpp.org/extensions/xep-0166.html">
  <front>
    <title>XEP-0166 Jingle</title>
    <author initials="." surname="XMPP Standards Foundation" fullname="XMPP Standards Foundation">
      <organization></organization>
    </author>
    <date year="2009" month="December" day="23"/>
  </front>
</reference>




<reference anchor='RFC3261'>

<front>
<title>SIP: Session Initiation Protocol</title>
<author initials='J.' surname='Rosenberg' fullname='J. Rosenberg'>
<organization /></author>
<author initials='H.' surname='Schulzrinne' fullname='H. Schulzrinne'>
<organization /></author>
<author initials='G.' surname='Camarillo' fullname='G. Camarillo'>
<organization /></author>
<author initials='A.' surname='Johnston' fullname='A. Johnston'>
<organization /></author>
<author initials='J.' surname='Peterson' fullname='J. Peterson'>
<organization /></author>
<author initials='R.' surname='Sparks' fullname='R. Sparks'>
<organization /></author>
<author initials='M.' surname='Handley' fullname='M. Handley'>
<organization /></author>
<author initials='E.' surname='Schooler' fullname='E. Schooler'>
<organization /></author>
<date year='2002' month='June' />
<abstract>
<t>This document describes Session Initiation Protocol (SIP), an application-layer control (signaling) protocol for creating, modifying, and terminating sessions with one or more participants.  These sessions include Internet telephone calls, multimedia distribution, and multimedia conferences. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='3261' />
<format type='TXT' octets='647976' target='http://www.rfc-editor.org/rfc/rfc3261.txt' />
</reference>



<reference anchor='RFC4566'>

<front>
<title>SDP: Session Description Protocol</title>
<author initials='M.' surname='Handley' fullname='M. Handley'>
<organization /></author>
<author initials='V.' surname='Jacobson' fullname='V. Jacobson'>
<organization /></author>
<author initials='C.' surname='Perkins' fullname='C. Perkins'>
<organization /></author>
<date year='2006' month='July' />
<abstract>
<t>This memo defines the Session Description Protocol (SDP).  SDP is intended for describing multimedia sessions for the purposes of session announcement, session invitation, and other forms of multimedia session initiation. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4566' />
<format type='TXT' octets='108820' target='http://www.rfc-editor.org/rfc/rfc4566.txt' />
</reference>



<reference anchor='RFC3264'>

<front>
<title>An Offer/Answer Model with Session Description Protocol (SDP)</title>
<author initials='J.' surname='Rosenberg' fullname='J. Rosenberg'>
<organization /></author>
<author initials='H.' surname='Schulzrinne' fullname='H. Schulzrinne'>
<organization /></author>
<date year='2002' month='June' />
<abstract>
<t>This document defines a mechanism by which two entities can make use of the Session Description Protocol (SDP) to arrive at a common view of a multimedia session between them.  In the model, one participant offers the other a description of the desired session from their perspective, and the other participant answers with the desired session from their perspective.  This offer/answer model is most useful in unicast sessions where information from both participants is needed for the complete view of the session.  The offer/answer model is used by protocols like the Session Initiation Protocol (SIP). [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='3264' />
<format type='TXT' octets='60854' target='http://www.rfc-editor.org/rfc/rfc3264.txt' />
</reference>



<reference anchor='RFC3711'>

<front>
<title>The Secure Real-time Transport Protocol (SRTP)</title>
<author initials='M.' surname='Baugher' fullname='M. Baugher'>
<organization /></author>
<author initials='D.' surname='McGrew' fullname='D. McGrew'>
<organization /></author>
<author initials='M.' surname='Naslund' fullname='M. Naslund'>
<organization /></author>
<author initials='E.' surname='Carrara' fullname='E. Carrara'>
<organization /></author>
<author initials='K.' surname='Norrman' fullname='K. Norrman'>
<organization /></author>
<date year='2004' month='March' />
<abstract>
<t>This document describes the Secure Real-time Transport Protocol (SRTP), a profile of the Real-time Transport Protocol (RTP), which can provide confidentiality, message authentication, and replay protection to the RTP traffic and to the control traffic for RTP, the Real-time Transport Control Protocol (RTCP). [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='3711' />
<format type='TXT' octets='134270' target='http://www.rfc-editor.org/rfc/rfc3711.txt' />
</reference>



<reference anchor='RFC5389'>

<front>
<title>Session Traversal Utilities for NAT (STUN)</title>
<author initials='J.' surname='Rosenberg' fullname='J. Rosenberg'>
<organization /></author>
<author initials='R.' surname='Mahy' fullname='R. Mahy'>
<organization /></author>
<author initials='P.' surname='Matthews' fullname='P. Matthews'>
<organization /></author>
<author initials='D.' surname='Wing' fullname='D. Wing'>
<organization /></author>
<date year='2008' month='October' />
<abstract>
<t>Session Traversal Utilities for NAT (STUN) is a protocol that serves as a tool for other protocols in dealing with Network Address Translator (NAT) traversal. It can be used by an endpoint to determine the IP address and port allocated to it by a NAT. It can also be used to check connectivity between two endpoints, and as a keep-alive protocol to maintain NAT bindings. STUN works with many existing NATs, and does not require any special behavior from them.&lt;/t>&lt;t> STUN is not a NAT traversal solution by itself. Rather, it is a tool to be used in the context of a NAT traversal solution. This is an important change from the previous version of this specification (RFC 3489), which presented STUN as a complete solution.&lt;/t>&lt;t> This document obsoletes RFC 3489. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5389' />
<format type='TXT' octets='125650' target='http://www.rfc-editor.org/rfc/rfc5389.txt' />
</reference>



<reference anchor='RFC5766'>

<front>
<title>Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)</title>
<author initials='R.' surname='Mahy' fullname='R. Mahy'>
<organization /></author>
<author initials='P.' surname='Matthews' fullname='P. Matthews'>
<organization /></author>
<author initials='J.' surname='Rosenberg' fullname='J. Rosenberg'>
<organization /></author>
<date year='2010' month='April' />
<abstract>
<t>If a host is located behind a NAT, then in certain situations it can be impossible for that host to communicate directly with other hosts (peers).  In these situations, it is necessary for the host to use the services of an intermediate node that acts as a communication relay.  This specification defines a protocol, called TURN (Traversal Using Relays around NAT), that allows the host to control the operation of the relay and to exchange packets with its peers using the relay.  TURN differs from some other relay control protocols in that it allows a client to communicate with multiple peers using a single relay address. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5766' />
<format type='TXT' octets='172112' target='http://www.rfc-editor.org/rfc/rfc5766.txt' />
</reference>



<reference anchor='RFC6347'>

<front>
<title>Datagram Transport Layer Security Version 1.2</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization /></author>
<author initials='N.' surname='Modadugu' fullname='N. Modadugu'>
<organization /></author>
<date year='2012' month='January' />
<abstract>
<t>This document specifies version 1.2 of the Datagram Transport Layer Security (DTLS) protocol.  The DTLS protocol provides communications privacy for datagram protocols.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  The DTLS protocol is based on the Transport Layer Security (TLS) protocol and provides equivalent security guarantees.  Datagram semantics of the underlying transport are preserved by the DTLS protocol.  This document updates DTLS 1.0 to work with TLS version 1.2. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='6347' />
<format type='TXT' octets='73546' target='http://www.rfc-editor.org/rfc/rfc6347.txt' />
</reference>



<reference anchor='RFC4960'>

<front>
<title>Stream Control Transmission Protocol</title>
<author initials='R.' surname='Stewart' fullname='R. Stewart'>
<organization /></author>
<date year='2007' month='September' />
<abstract>
<t>This document obsoletes RFC 2960 and RFC 3309. It describes the Stream Control Transmission Protocol (SCTP). SCTP is designed to transport Public Switched Telephone Network (PSTN) signaling messages over IP networks, but is capable of broader applications.&lt;/t>&lt;t> SCTP is a reliable transport protocol operating on top of a connectionless packet network such as IP. It offers the following services to its users:&lt;/t>&lt;t> -- acknowledged error-free non-duplicated transfer of user data,&lt;/t>&lt;t> -- data fragmentation to conform to discovered path MTU size,&lt;/t>&lt;t> -- sequenced delivery of user messages within multiple streams, with an option for order-of-arrival delivery of individual user messages,&lt;/t>&lt;t> -- optional bundling of multiple user messages into a single SCTP packet, and&lt;/t>&lt;t> -- network-level fault tolerance through supporting of multi-homing at either or both ends of an association.&lt;/t>&lt;t> The design of SCTP includes appropriate congestion avoidance behavior and resistance to flooding and masquerade attacks. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4960' />
<format type='TXT' octets='346022' target='http://www.rfc-editor.org/rfc/rfc4960.txt' />
</reference>



<reference anchor='RFC4568'>

<front>
<title>Session Description Protocol (SDP) Security Descriptions for Media Streams</title>
<author initials='F.' surname='Andreasen' fullname='F. Andreasen'>
<organization /></author>
<author initials='M.' surname='Baugher' fullname='M. Baugher'>
<organization /></author>
<author initials='D.' surname='Wing' fullname='D. Wing'>
<organization /></author>
<date year='2006' month='July' />
<abstract>
<t>This document defines a Session Description Protocol (SDP) cryptographic attribute for unicast media streams.  The attribute describes a cryptographic key and other parameters that serve to configure security for a unicast media stream in either a single message or a roundtrip exchange.  The attribute can be used with a variety of SDP media transports, and this document defines how to use it for the Secure Real-time Transport Protocol (SRTP) unicast media streams.  The SDP crypto attribute requires the services of a data security protocol to secure the SDP message. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4568' />
<format type='TXT' octets='107881' target='http://www.rfc-editor.org/rfc/rfc4568.txt' />
</reference>



<reference anchor='RFC2119'>

<front>
<title abbrev='RFC Key Words'>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='Scott Bradner'>
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass. Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>
<phone>- +1 617 495 3864</phone>
<email>sob@harvard.edu</email></address></author>
<date year='1997' month='March' />
<area>General</area>
<keyword>keyword</keyword>
<abstract>
<t>
   In many standards track documents several words are used to signify
   the requirements in the specification.  These words are often
   capitalized.  This document defines these words as they should be
   interpreted in IETF documents.  Authors who follow these guidelines
   should incorporate this phrase near the beginning of their document:

<list>
<t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in
      RFC 2119.
</t></list></t>
<t>
   Note that the force of these words is modified by the requirement
   level of the document in which they are used.
</t></abstract></front>

<seriesInfo name='BCP' value='14' />
<seriesInfo name='RFC' value='2119' />
<format type='TXT' octets='4723' target='http://www.rfc-editor.org/rfc/rfc2119.txt' />
<format type='HTML' octets='17970' target='http://xml.resource.org/public/rfc/html/rfc2119.html' />
<format type='XML' octets='5777' target='http://xml.resource.org/public/rfc/xml/rfc2119.xml' />
</reference>



<reference anchor='RFC4733'>

<front>
<title>RTP Payload for DTMF Digits, Telephony Tones, and Telephony Signals</title>
<author initials='H.' surname='Schulzrinne' fullname='H. Schulzrinne'>
<organization /></author>
<author initials='T.' surname='Taylor' fullname='T. Taylor'>
<organization /></author>
<date year='2006' month='December' />
<abstract>
<t>This memo describes how to carry dual-tone multifrequency (DTMF) signalling, other tone signals, and telephony events in RTP packets. It obsoletes RFC 2833.&lt;/t>&lt;t> This memo captures and expands upon the basic framework defined in RFC 2833, but retains only the most basic event codes. It sets up an IANA registry to which other event code assignments may be added. Companion documents add event codes to this registry relating to modem, fax, text telephony, and channel-associated signalling events. The remainder of the event codes defined in RFC 2833 are conditionally reserved in case other documents revive their use.&lt;/t>&lt;t> This document provides a number of clarifications to the original document. However, it specifically differs from RFC 2833 by removing the requirement that all compliant implementations support the DTMF events. Instead, compliant implementations taking part in out-of-band negotiations of media stream content indicate what events they support. This memo adds three new procedures to the RFC 2833 framework: subdivision of long events into segments, reporting of multiple events in a single packet, and the concept and reporting of state events. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4733' />
<format type='TXT' octets='115614' target='http://www.rfc-editor.org/rfc/rfc4733.txt' />
</reference>




    </references>




  </back>
</rfc>

